---
tags: whats-new
layout: whats-new-post.njk
permalink: whats-new/writeup-of-our-first-unison-meetup/index.html
summary: We had our first ever Unison meetup last Tuesday! If you missed it or
  just want to look back on it fondly (or if like me you struggle to remember
  anything from more than 2 days ago..), this post is for you!!
featuredImage: /assets/thing1.svg
categories:
  - news
  - announcements
authors:
  - paul-chiusano
date: 2019-04-04T00:00:00.000Z
title: Writeup of our first Unison meetup
---

{% raw %}
<article class="unison-doc"><section><p></p><section><p><span class="span"><span class="word">We had our</span><span class="group"><span class="join"><a href="https://www.meetup.com/Boston-Unison/events/259532783/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">first ever Unison meetup last Tuesday</span></span></a><span class="word">!</span></span></span><span class="word">If you missed it or just want to look back on it fondly (or if like me you struggle to remember anything from more than 2 days ago..), this post is for you!! Myself, Arya, and Rúnar planned the agenda and presented. Overall: it was a lot of fun and I found it meaningful and motivating, thanks to everyone who came and who helped make it a success!</span></span></p><p><span class="span"><span class="word">After some pizza and mingling, I started by giving a quick intro to Unison and the motivation for it: programming is fun, useful, and beautiful, and deserves great languages and tools that make the programming process delightful or at least REASONABLE in all aspects. Sadly, very little about how programming works has been intentionally designed or crafted; things are often done some way because of uncareful decision made long ago when computers still had 640kb of memory and we just didn't know better. 😬 Unison started as an experiment: what if you rethought programming today and tried to make it as amazing as possible?</span></span></p><p><span class="span"><span class="word">Our thesis: there's one area in particular where current programming languages and tools result in lots of complexity, and that's building distributed, elastic systems. Though we're trying to improve programming generally, making whole distributed systems simply describable using one language has been an important motivator for the work on Unison, and led us to some core technical decisions.</span></span></p><p><span class="span"><span class="word">From there, Arya and Rúnar introduced themselves and then we went right into a demo of Unison, as it stands today. It was a small group so we encouraged people to jump in with questions, and there were a lot of questions and discussion, which was all good! I'll include some of the questions inline as I go, and then some additional ones at the end. (Also, if you were at the event and this writeup is missing something, please leave a comment!)</span></span></p><p><span class="span"><span class="word">Rúnar kicked off the demo by starting the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">command line tool, which he put on one half of the screen, and a text editor (he's a Vim user) on the other side. We're used to thinking of "the codebase" as a bag of text files that we mutate in order to evolve our codebase, but in Unison, the codebase is a more structured object which undergoes a series of well-typed transformations and is never in a broken state, more like a purely functional data structure.</span></span></p><p><span class="span"><span class="word">He showed a little bit of the actual repository structure too: the codebase isn't just a giant binary database file, it has a directory structure that's designed with some cleverness to avoid ever producing a git merge conflict.</span></span></p><p><span class="span"><span class="word">&gt; Q: How? A: There are a few tricks but an important idea is to name files based on a hash of their content. Thus, files in the codebase format never change, only new files are introduced, and git merges directories of such files by taking their union.</span></span></p><p><span class="span"><span class="word">When you start up</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">,</span></span></span><span class="word">it watches for changes to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">.u</span></code></span><span class="word">files (which contain Unison code) in the current directory or any of its subdirectories. When it detects a change, it parses and typechecks any definitions in the file and then evaluates any "watch expressions", which are just lines starting with</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">&gt;</span></code></span><span class="word">.</span></span></span><span class="word">So one of the first things Rúnar did was open up a file</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">meetup1.u</span></code></span><span class="word">,</span></span></span><span class="word">and type:</span></span></p><div class="rich source code unison"><pre><code><span class="word">&gt; 4 + 4</span></code></pre></div><p><span class="span"><span class="word">After saving the file,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">instantly responded with:</span></span></p><div class="rich source code ucm"><pre><code><span class="word">master&gt;

┌
│  1 | &gt; 4 + 4
│        ⧩
│        8
└</span></code></pre></div><p><span class="span"><span class="word">Here's a screenshot of the setup:</span></span></p><img src="/assets/feed/writeup-of-our-first-unison-meetup/basic-setup.png" alt="Basic setup writing Unison"><p><span class="span"><span class="word">This makes for a nice little interactive loop when developing code, and it replaces the need for a REPL (no more typing import statements or switching to a separate line-oriented editor to quickly test your code).</span></span></p><p><span class="span"><span class="word">&gt; Also note: the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">meetup1&gt;</span></code></span><span class="word">prompt from the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">tool is saying that the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">meetup1</span></code></span><span class="word">is the current active branch. The Unison codebase has a notion of branches, which you can</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">fork</span></code></span><span class="word">,</span></span></span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">merge</span></code></span><span class="word">,</span></span></span><span class="word">etc, similar to git, but they aren't modeled as git branches and you can easily reference code from multiple branches in the same program (which is useful for say, profiling or other cross-branch comparisons that are annoying to do in git).</span></span></p><p><span class="span"><span class="word">From there, Rúnar wrote a function</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">,</span></span></span><span class="word">which generates a list by repeatedly applying a function to some state to produce an output value and a new state. He then used it to generate the powers of 2 less than 100:</span></span></p><div class="rich source code unison"><pre><code><span class="word">use Optional None Some

unfold : s -&gt; (s -&gt; Optional (a, s)) -&gt; [a]
unfold s f = case f s of
  None -&gt; []
  Some (a, s') -&gt; a `cons` unfold s' f

&gt; unfold 1 (n -&gt; if n &lt; 100 then Some (n, n * 2)
                 else None)</span></code></pre></div><img src="/assets/feed/writeup-of-our-first-unison-meetup/unfold.png" alt="Unfold implementation"><p><span class="span"><span class="word">Once he was satisfied with that, he typed</span><span class="rich source inline-code"><code class="inline-code"><span class="word">add</span></code></span><span class="word">in the command line tool to add the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">definition to the codebase. He then</span><strong><span class="word">deleted</span></strong><span class="word">the code from his</span><span class="rich source inline-code"><code class="inline-code"><span class="word">meetup1.u</span></code></span><span class="word">scratch file!! We don't need the original source once the code has been slurped up into the codebase since we can view or edit it at any time later. He demonstrated this by typing</span><span class="rich source inline-code"><code class="inline-code"><span class="word">view unfold</span></code></span><span class="word">which showed the very same</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">function he just wrote (but autoformatted) and then</span><span class="rich source inline-code"><code class="inline-code"><span class="word">edit unfold</span></code></span><span class="word">which added this source code to the top of his scratch file for further editing.</span></span></p><p><span class="span"><span class="word">Rúnar showed a few other features of the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">tool: you can easily search for and view definitions that exist in the codebase, and you can trivially rename definitions. So for instance, he took a look at the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">type, which is used by</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">:</span></span></span></span></p><div class="rich source code ucm"><pre><code><span class="word">&gt; view Optional

  type Optional a = None | Some a</span></code></pre></div><p><span class="span"><span class="word">And he then did a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">rename Optional.None Nothing</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">rename Optional.Some
            Just</span></code></span><span class="word">,</span></span></span><span class="word">renaming those two constructors of</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Nothing</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Just</span></code></span><span class="word">.</span></span></span><span class="word">A subsequent</span><span class="rich source inline-code"><code class="inline-code"><span class="word">view unfold</span></code></span><span class="word">showed this rename had been propagated:</span></span></p><div class="rich source code unison"><pre><code><span class="word">unfold : s -&gt; (s -&gt; Optional (a, s)) -&gt; [a]
unfold s f = case f s of
  Nothing -&gt; []
  Just (a, s') -&gt; a `cons` unfold s' f</span></code></pre></div><p><span class="span"><span class="word">He emphasized an important point here that this</span><span class="rich source inline-code"><code class="inline-code"><span class="word">rename</span></code></span><span class="word">operation isn't like an IDE doing a bunch of text munging on your behalf, resulting in a massive textual diff and also breaking any code outside your IDE's purview (like your library's downstream users). Rather, the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">definition and any other code that depends on</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">is</span><span class="italic"><span class="span"><span class="word">completely unchanged</span></span></span><span class="word">by the renaming of the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional</span></code></span><span class="word">constructors, and you're free to make these name changes without fear of breaking anything (even code you don't know about). A</span><span class="rich source inline-code"><code class="inline-code"><span class="word">rename</span></code></span><span class="word">is always 100% accurate and instantaneous. Nice!!</span></span></p><p><span class="span"><span class="word">Unison achieves this by giving a unique, content-based cryptographic hash for each definition, and referring to other code using these hashes. The mapping of names to hashes is just metadata for humans, used to resolve names to hashes at parse time when slurping up code into the codebase, and used for the other direction when displaying code for the user. Doing</span><span class="rich source inline-code"><code class="inline-code"><span class="word">ls -l unfold</span></code></span><span class="word">(vs just</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">ls unfold</span></code></span><span class="word">)</span></span></span><span class="word">shows the hashes alongside the signatures, which Rúnar also showed.</span></span></p><p><span class="span"><span class="word">People had a bunch of questions, here are a few of them:</span></span></p><ul><li><ul class="column"><li><span class="span"><span class="word">Could the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">find</span></code></span><span class="word">/</span><span class="rich source inline-code"><code class="inline-code"><span class="word">ls</span></code></span><span class="word">command show docstrings or other more useful information besides just the type signature?</span></span></li><li><ul><li><span class="span"><span class="word">Yes, totally, this is a good idea! Not implemented yet though.</span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">Are these hashes affected by variable names?</span></span></li><li><ul><li><span class="span"><span class="word">No. Variable names are converted to their</span><a href="https://en.wikipedia.org/wiki/De_Bruijn_index" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">De Bruijn index</span></span></a><span class="word">as part of the hashing algorithm, so name choices don't affect the hash. For instance</span><span class="rich source inline-code"><code class="inline-code"><span class="word">id x = x</span></code></span><span class="word">will hash the same as</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">identity a = a</span></code></span><span class="word">,</span></span></span><span class="word">since both the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">a</span></code></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">x</span></code></span><span class="word">will have the same De Bruijn index of</span><span class="group"><span class="join"><span class="italic"><span class="word">0</span></span><span class="word">.</span></span></span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">What happens to comments?</span></span></li><li><ul><li><span class="span"><span class="word">Currently, they are thrown out by the lexer! This is pretty silly. An uncontroversial choice would be to just not do that and instead attach them to the AST.</span></span></li><li><span class="span"><span class="word">But there is some room for innovation here, making comments more structured, rather than just blobs of freeform text. (For instance, imagine if comments mentioning</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Optional.None</span></code></span><span class="word">could be automatically renamed as well, with 100% accuracy.)</span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">Are module cycles a thing?</span></span></li><li><ul><li><span class="span"><span class="word">No. You only have a cycle if you have mutually recursive definitions. You can never create a cycle by adding a new definition that references only previous definitions. This behavior comes for free because Unison tracks dependencies at the most fine-grained level possible: individual definitions.</span></span></li></ul></li></ul></li></ul><p><span class="span"><span class="word">We pointed out that you can also give multiple names to the same hash and you can depend on a single definition rather than an entire library. This led to more good questions:</span></span></p><ul><li><ul class="column"><li><span class="span"><span class="word">Hmm, how do these more fine grained dependencies work out in practice? What about the diamond dependency problem and dependency hell?</span></span></li><li><ul><li><span class="span"><span class="word">We punted on talking about this one in detail (but it would be cool to spend a session even just on this), but the basic answer is that many of these concerns just disappear with the Unison approach of making all definitions immutable and content addressed. We should do a follow-up post on this one.</span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">Can people use their own naming preferences for the same definitions?</span></span></li><li><ul><li><span class="span"><span class="word">That makes total conceptual sense and would be easy to do but we haven't implemented anything for it yet.</span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">What happens if two people pick the same name (say</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">frobnicate</span></code></span><span class="word">)</span></span></span><span class="word">for different definitions?</span></span></li><li><ul><li><span class="span"><span class="word">That's fine as long as</span><span class="rich source inline-code"><code class="inline-code"><span class="word">frobnicate</span></code></span><span class="word">names exist in separate branches: each Unison branch gets its own namespace. If those branches get merged, then Unison will encourage (but not require) that you rename one or both. In the meantime, the merged branch is still usable and the names will be shown as</span><span class="rich source inline-code"><code class="inline-code"><span class="word">frobnicate#2aQjd</span></code></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">frobnicate#9jfPv</span></code></span><span class="word">(we call these names "hash-qualified").</span></span></li><li><span class="span"><span class="word">Also: you can use qualified names, like</span><span class="rich source inline-code"><code class="inline-code"><span class="word">pchiusano.utils.frobnicate</span></code></span><span class="word">and we expect people will do this. If people adopt this convention, name conflicts arise more when people working within the same project, like if Alice and Bob both add a different</span><span class="rich source inline-code"><code class="inline-code"><span class="word">frobnicate</span></code></span><span class="word">definition to the same module.</span></span></li></ul></li></ul></li></ul></section><section><h1 id="fuzzy-string-matching"><span class="span"><span class="word">Fuzzy string matching</span></span></h1><p><span class="span"><span class="word">Rúnar then handed it over to me to implement something a little less trivial. I used his</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">function to implement a fuzzy text matching algorithm. Before prepping the talk, I was only familiar with using edit distance for this purpose, but I recently learned a nifty little algorithm, called</span><span class="group"><span class="join"><a href="http://www.catalysoft.com/articles/StrikeAMatch.html" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Strike A Match</span></span></a><span class="word">,</span></span></span><span class="word">which I implemented. The algorithm just</span><span class="group"><span class="join"><span class="italic"><span class="span"><span class="word">compares the overlap in the set of adjacent character pairs</span></span></span><span class="word">.</span></span></span><span class="word">So, for instance, the text</span><span class="rich source inline-code"><code class="inline-code"><span class="word">"Alice"</span></code></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">"Alicia"</span></code></span><span class="word">can be broken up into the character pairs:</span></span></p><div class="rich source code raw"><pre><code><span class="word">"Alice"  -&gt; {"Al", "li", "ic", "ce"}
"Alicia" -&gt; {"Al", "li", "ic", "ci", "ia"}</span></code></pre></div><p><span class="span"><span class="word">Notice it has three character pairs in common (''{"Al", "li", "ic"}''), among 6 total in their union. So a simple metric of their similarity is just the size of the intersection divided by the size of the union (sometimes called the</span><span class="group"><span class="join"><a href="https://en.wikipedia.org/wiki/Jaccard_index" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Jacaard index</span></span></a><span class="word">).</span></span></span></span></p><p><span class="span"><span class="word">First I started implementing</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">sliding</span></code></span><span class="word">,</span></span></span><span class="word">a function to get all these adjacent character pairs, using</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unfold</span></code></span><span class="word">.</span></span></span><span class="word">I showed how you can type any unbound symbol (I like</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">hmm</span></code></span><span class="word">)</span></span></span><span class="word">and have Unison tell you what type it's expecting there, which is handy when filling in arguments.</span></span></p><img src="/assets/feed/writeup-of-our-first-unison-meetup/sliding.png" alt="Using unfold to generate adjacent character pairs (1)"><p><span class="span"><span class="word">Eventually I got:</span></span></p><div class="rich source code unison"><pre><code><span class="word">sliding : Text -&gt; [Text]
sliding t =
  step t = if Text.size t &lt; 2 then None
           else Some (take 2 t, drop 1 t)
  unfold t step

&gt; sliding "Alicia"</span></code></pre></div><img src="/assets/feed/writeup-of-our-first-unison-meetup/sliding2.png" alt="Using unfold to generate adjacent character pairs (2)"><p><span class="span"><span class="word">And then after that worked fine, I went ahead and used</span><span class="rich source inline-code"><code class="inline-code"><span class="word">sliding</span></code></span><span class="word">to implement the similarity function:</span></span></p><div class="rich source code unison"><pre><code><span class="word">-- number in 0 to 100 where 100 means sets are the same
-- 0 they are totally different
jacaard : Set a -&gt; Set a -&gt; Nat
jacaard s1 s2 =
  100 * (Set.size (s1 `intersect` s2))
      / (Set.size (s1 `union` s2))

-- uses type-directed name resolution to resolve to Set.fromSequence
-- should be 50, since intersection is size 1, and union is size 2
&gt; jacaard (fromSequence [1]) (fromSequence [1,2])

similarity : Text -&gt; Text -&gt; Nat
similarity t1 t2 =
  jacaard (fromSequence (sliding t1))
          (fromSequence (sliding t2))

&gt; similarity "Alice" "Alice"
&gt; similarity "Alice" "Alicia"
&gt; similarity "Alice" "Bob"
&gt; similarity "French" "France"</span></code></pre></div><p><span class="span"><span class="word">Here's the output:</span></span></p><div class="rich source code raw"><pre><code><span class="word">┌
│  8 | &gt; sliding "Alicia"
│        ⧩
│        ["Al", "li", "ic", "ci", "ia"]
└
┌
│  16 | &gt; jacaard (fromSequence [1]) (fromSequence [1,2])
│         ⧩
│         50
└
┌
│  23 | &gt; similarity "Alice" "Alice"
│         ⧩
│         100
└
┌
│  24 | &gt; similarity "Alice" "Alicia"
│         ⧩
│         50
└
┌
│  25 | &gt; similarity "Alice" "Bob"
│         ⧩
│         0
└
┌
│  26 | &gt; similarity "French" "France"
│         ⧩
│         25
└</span></code></pre></div><p><span class="word">Success!!</span></p><p><span class="span"><span class="word">Since I've started programming with watch expressions that instantly update like this, I never want to go back to using a REPL for exploration or quick testing, and it's possible to extend the idea just a little bit to support writing tests that become a more permanent artifact of your codebase as well (and the test results can be perfectly incrementally computed).</span></span></p></section><section><h1 id="refactoring"><span class="word">Refactoring</span></h1><p><span class="span"><span class="word">Arya then took over, showing our progress on making it nice to refactor a Unison codebase. He has more of a writeup</span><span class="group"><span class="join"><a href="../updates.html#post-start" class="named-link" rel="noopener" target="_self"><span class="span"><span class="word">in this post</span></span></a><span class="word">.</span></span></span><span class="word">The basic idea is that you are never dealing with a morass of compile errors, many of which are misleading or covering up other errors. Instead, the command line tool walks you through the refactoring step by step, one update at a time, in a sensible order that avoids repeatedly updating the same definitions. Even though there's more work to do to make the actual UI for this nice, I'm convinced that the approach is the Right Thing™️ and in the future we'll look back on the status quo and wonder WTH we were thinking!</span></span></p></section><section><h1 id="other-questions"><span class="span"><span class="word">Other questions</span></span></h1><p><span class="span"><span class="word">Here's a smattering of other questions that I remember (if I've missed any please leave a comment):</span></span></p><ul><li><ul class="column"><li><span class="span"><span class="word">What's the type system?</span></span></li><li><ul><li><span class="span"><span class="word">Unison starts with Dunfield and Krishnaswami's</span><span class="group"><span class="join"><a href="https://www.cl.cam.ac.uk/~nk480/bidir.pdf" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism</span></span></a><span class="word">.</span></span></span><span class="word">That type system has very good type inference and supports higher supports higher-rank types as well. I'd say our extensions to what's in the paper were very straightforward: we added data types, pattern matching, let / let rec, and a few other language constructs which weren't in the original paper for simplicity. Neel Krishnaswami was helpful in answering various questions we encountered while implementing it!</span></span></li><li><span class="span"><span class="word">For Unison's algebraic effects, we adapted</span><span class="group"><span class="join"><a href="https://arxiv.org/abs/1611.09259" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Frank's type system</span></span></a><span class="word">,</span></span></span><span class="word">by Lindley, McBride, and McLaughlin, and Conor McBride helped in answering questions abaout it. Some of the changes vs Frank are kind of interesting and we'll probably do a writeup of that at some point.</span></span></li></ul></li></ul></li><li><ul class="column"><li><span class="span"><span class="word">What about bounded polymorphism and typeclasses? This deserves a longer post, but here are a few answers:</span></span></li><li><ul><li><span class="span"><span class="word">For just name overloading, Unison supports that via type-directed name resolution.</span></span></li><li><span class="span"><span class="word">For effectful programming, you use algebraic effects, no need to pass dictionaries around.</span></span></li><li><span class="span"><span class="word">Functions like</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">&lt;</span></code></span><span class="word">,</span></span></span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">==</span></code></span><span class="word">,</span></span></span><span class="word">etc, work for any type (actually we'll probably restrict their type a bit just to keep parametricity in tact). But these are builtins, you can't implement your own (could we somehow make that possible though?).</span></span></li><li><span class="span"><span class="word">The only thing that Unison has which is as general as typeclasses is explicit dictionary passing. This can sometimes be a bit tedious.</span></span></li><li><span class="span"><span class="word">Typeclasses are super convenient but I don't think that as is they're a good fit for Unison, and they have problems even in the Haskell world (</span><a href="http://pchiusano.github.io/2018-02-13/typeclasses.html" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">relevant post</span></span></a><span class="word">). Also, not for nothing: they're a pain to implement.</span></span></li><li><span class="span"><span class="word">Summary: We're thinking about it. If you've got ideas, let us know!</span></span></li></ul></li></ul></li></ul><p><span class="span"><span class="word">There was an interesting discussion around typeclasses after the meetup (some folks headed over to a local pub for drinks and food). All the approaches to bounded polymorphism (typeclasses a la Haskell, modules a la ML / Scala, dictionary passing + implicit parameters, OO style subtyping ..) have strengths and weaknesses. And that's the problem: there's no approach that's a total slam dunk, which makes you think "YES, PROBLEM 100% SOLVED." Every approach has its issues. I'm hoping for some bolt of insight about this…</span></span></p></section><section><h1 id="thats-all"><span class="span"><span class="word">That's all!</span></span></h1><p><span class="span"><span class="word">I hope this writeup was useful for folks. We're going to try doing the meetups monthly. Something else we've considered doing in addition to the in person meetups is an "online only" meetup over Twitch. If you're not local to the Boston area but have an interest in doing something like this, let us know!</span></span></p></section></section><div class="tooltips" style="display: none;"></div></article>
{% endraw %}
