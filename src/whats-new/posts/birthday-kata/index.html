---
tags: whats-new
layout: whats-new-post.njk
permalink: whats-new/birthday-kata/index.html
summary: Thank you Tavish Pegram for being the first in our community blogpost
  series! In this post, Tavish walks through a popular 'kata' for practicing
  test driven development and hexagonal architecture. Along the way, he explores
  Unison's type system, abilities, and testing conventions.
featuredImage: /assets/thing7.svg
categories:
  - community
authors:
  - tavish-pegram
date: 2021-08-20T00:00:00.000Z
title: Practical Example - Modeling a Birthday Message Service
---

{% raw %}
<article class="unison-doc"><section><p></p><section><section><h2 id="community-series"><span class="span"><span class="word">Community Series</span></span></h2><p><span class="span"><span class="word">Hi folks, Rebecca Mark here, kicking off the new Unison community focused blogpost series. In this series, we're going to be featuring different contributors' work in addition to the usual release notes and company news. We want the blog to highlight Unison community voices and projects because we know that no programming language exists without the people who write in it and the problems they're interested in solving. We hope to feature more community generated content in the future! If you have an engineering topic or Unison project you'd like to write about, email</span><a href="mailto:community@unison.cloud" class="named-link" rel="noopener" target="_self"><span class="word">community@unison.cloud</span></a><span class="word">and get in touch.</span></span></p><p><span class="span"><span class="word">With that in mind, we'll turn it over to the author of this post: Tavish Pegram. Tavish is a Software Engineer at Peloton. His interests include DDD, FP, TDD, XP, and other letters as well.</span></span></p></section><section><h2 id="the-kata"><span class="span"><span class="word">The Kata</span></span></h2><p><a href="http://matteo.vaccari.name/blog/archives/154" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Source: Matteo Vaccari</span></span></a></p><section><h3 id="goals"><span class="word">Goals</span></h3><p><span class="span"><span class="word">This kata is normally used to practice TDD, dependency injection, and ports and adapters architectures in an Object Oriented style. Instead, we will tackle the same problem in Unison and explore TDD, dependency rejection, and how pure FP languages naturally encourage ports and adapters like architectures (through seperation of pure and impure functions).</span></span></p><p><span class="span"><span class="word">If you aren't familiar with "ports and adapters" (also called "Hexagonal Architecture", "The Clean Architecture", and "The Onion Architecture") the idea is to invert dependencies between pure business logic and infrastructure code, usually using interfaces, so that implementation details like the DB, transfer protocols, etc. is fully decoupled from the actual business logic -- making it easier to extend, update, maintain, and test!</span></span></p><p><span class="span"><span class="word">At a more technical level, we will explore how to do domain modeling with the Unison type system, how to use abilities, and how to write tests.</span></span></p></section><section><h3 id="the-prompt"><span class="span"><span class="word">The Prompt</span></span></h3><p><span class="span"><span class="word">As the HR department, I want to send an email to every employee on their birthday so that they feel appreciated and company morale is kept high.</span></span></p><p><span class="span"><span class="word">Technical Notes:</span></span></p><ol start="1"><li><span class="span"><span class="word">Loads a set of employees from somewhere (we haven't decided yet if its a database, or a flat file, or just in memory)</span></span></li><li><span class="span"><span class="word">Sends an email to all employees whose birthday is today.</span></span></li></ol><p><span class="span"><span class="word">Platform Goals:</span></span></p><ol start="1"><li><span class="span"><span class="word">Testable: we should be able to test the internal application logic with no need to ever send a real email.</span></span></li><li><span class="span"><span class="word">Flexible: we anticipate that the data source in the future could change from a flat file to a relational database, or perhaps a web service. We also anticipate that the email service could soon be replaced with a service that sends greetings through Facebook or some other social network.</span></span></li><li><span class="span"><span class="word">Well-designed: clearly separate the business logic from the infrastructure.</span></span></li></ol><p><span class="span"><span class="word">For further information about this kata please checkout the original post</span><span class="group"><span class="join"><a href="http://matteo.vaccari.name/blog/archives/154" class="named-link" rel="noopener" target="_blank"><span class="word">here</span></a><span class="word">.</span></span></span></span></p></section><section><h3 id="our-approach"><span class="span"><span class="word">Our Approach</span></span></h3><p><span class="span"><span class="word">First, we will come up with a rich domain model and discuss different ways we can model the system to take advantage of the compiler and what the resulting tradeoffs are.</span></span></p><p><span class="span"><span class="word">Second, we will talk about Abilities, dependency injection / rejection, and how we can decouple possibly impure infrastructure from pure decision making logic.</span></span></p><p><span class="span"><span class="word">Third, we will apply TDD to implement our behavior.</span></span></p></section></section><section><h2 id="modeling"><span class="word">Modeling</span></h2><p><span class="span"><span class="word">Unison provides us with all the algebraic data types we need to build and compose types. In lieu of discussing them up front, we will just jump into modeling and discuss syntax and decisions as we go!</span></span></p><p><span class="span"><span class="word">From skimming over the prompt, it seems pretty clear that top level types we need are</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Employee</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Email</span></code></span><span class="word">.</span></span></span><span class="word">Let's start with</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Employee</span></code></span><span class="word">.</span></span></span></span></p><section><h3 id="employee"><span class="word">Employee</span></h3><p><span class="span"><span class="word">So what is an employee to us? For one, they are an entity and therefore should have a unique</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">id</span></code></span><span class="word">.</span></span></span><span class="word">Some other fields we probably care about include the employee's</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">name</span></code></span><span class="word">,</span></span></span><span class="word">and importantly, their</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">birthday</span></code></span><span class="word">.</span></span></span></span></p><p><span class="span"><span class="word">Obviously, there are millions of other fields we could choose to include in our model, but we would also like to only include what we care about. In a larger more complex system, the Employee model may have many other fields we don't care about but make sense to include in the broader modelling context (see "bounded context", Domain Driven Design).</span></span></p><p><span class="span"><span class="word">So lets start with:</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type EmployeeId = EmployeeId Text
unique type FirstName = FirstName Text
unique type LastName = LastName Text
unique type Name =
  { first: FirstName
  , last: LastName
  }
unique type Date =
  { day: Nat
  , month: Nat
  , year: Nat
  }
unique type Employee =
  { id: EmployeeId
  , name: Name
  , birthday: Date
  }</span></code></pre></div><section><h4 id="decision-1---record-types"><span class="span"><span class="word">Decision 1 - Record Types</span></span></h4><p><span class="span"><span class="word">Our employee is a record type consisting of an</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">id</span></code></span><span class="word">,</span></span></span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">name</span></code></span><span class="word">,</span></span></span><span class="word">and a</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">birthday</span></code></span><span class="word">.</span></span></span><span class="word">In Unison, the record type syntax is actually equivalent to a normal data type like</span></span></p><div class="rich source code unison"><pre><code><span class="word">type Employee = Employee EmployeeId Name Date</span></code></pre></div><p><span class="span"><span class="word">except the compiler will automatically generate a collection of functions that allow for easy access and updates of this immutable data structure, which will be a big help later. You can see this in the output in</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">ucm</span></code></span><span class="word">:</span></span></span></span></p><div class="rich source code ucm"><pre><code><span class="word">I found and typechecked these definitions in ~/projects/scratch.u. If you do an `add` or
  `update`, here's how your codebase would change:

    ⍟ These new definitions are ok to `add`:

      unique type Date
      unique type Employee
      unique type EmployeeId
      unique type FirstName
      unique type LastName
      unique type Name
      Date.day                 : Date -&gt; Nat
      Date.day.modify          : (Nat -&gt;{g} Nat) -&gt; Date -&gt;{g} Date
      Date.day.set             : Nat -&gt; Date -&gt; Date
      Date.month               : Date -&gt; Nat
      Date.month.modify        : (Nat -&gt;{g} Nat) -&gt; Date -&gt;{g} Date
      Date.month.set           : Nat -&gt; Date -&gt; Date
      Date.year                : Date -&gt; Nat
      Date.year.modify         : (Nat -&gt;{g} Nat) -&gt; Date -&gt;{g} Date
      Date.year.set            : Nat -&gt; Date -&gt; Date
      Employee.birthday        : Employee -&gt; Date
      Employee.birthday.modify : (Date -&gt;{g} Date) -&gt; Employee -&gt;{g} Employee
      Employee.birthday.set    : Date -&gt; Employee -&gt; Employee
      Employee.id              : Employee -&gt; EmployeeId
      Employee.id.modify       : (EmployeeId -&gt;{g} EmployeeId) -&gt; Employee -&gt;{g} Employee
      Employee.id.set          : EmployeeId -&gt; Employee -&gt; Employee
      Employee.name            : Employee -&gt; Name
      Employee.name.modify     : (Name -&gt;{g} Name) -&gt; Employee -&gt;{g} Employee
      Employee.name.set        : Name -&gt; Employee -&gt; Employee
      Name.first               : Name -&gt; FirstName
      Name.first.modify        : (FirstName -&gt;{g} FirstName) -&gt; Name -&gt;{g} Name
      Name.first.set           : FirstName -&gt; Name -&gt; Name
      Name.last                : Name -&gt; LastName
      Name.last.modify         : (LastName -&gt;{g} LastName) -&gt; Name -&gt;{g} Name
      Name.last.set            : LastName -&gt; Name -&gt; Name</span></code></pre></div><p><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">Name</span></code></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Date</span></code></span><span class="word">are record types as well.</span></span></p></section><section><h4 id="decision-2---nominal-vs-structural-typing"><span class="span"><span class="word">Decision 2 - Nominal vs Structural Typing</span></span></h4><p><span class="span"><span class="word">Also note that we have opted in to using nominal typing (with the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unique</span></code></span><span class="word">keyword) instead of structural typing. If we had left out</span><span class="rich source inline-code"><code class="inline-code"><span class="word">unique</span></code></span><span class="word">the compiler would consider</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeId</span></code></span><span class="word">,</span></span></span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">FirstName</span></code></span><span class="word">,</span></span></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">LastName</span></code></span><span class="word">all to be the same type (with all names being interchangeable). For our current use case, we want to make sure that the compiler considers all of these different types, so we can prevent mistakes like accidentally passing in a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">LastName</span></code></span><span class="word">where an</span><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeId</span></code></span><span class="word">should go.</span></span></p></section><section><h4 id="decision-3---avoiding-primitives"><span class="span"><span class="word">Decision 3 - Avoiding Primitives</span></span></h4><p><span class="span"><span class="word">We could have also modeled the Employee like this (or any other similar way)</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Employee =
  { id: Text
  , name: Name
  , birthday: Date
  }

unique type Name =
  { first: Text
  , last: Text
  }

unique type Date =
  { day: Nat
  , month: Nat
  , year: Nat
  }</span></code></pre></div><p><span class="span"><span class="word">When deciding whether to use primitives or to wrap them in more rich domain types we should consider some tradeoffs:</span></span></p><ol start="1"><li><span class="span"><span class="word">Using primitive types gives the compiler less context on what you are attempting to model. For example, using</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Text</span></code></span><span class="word">for the id, the first name, and the last name, means the compiler wouldn't catch an easy mistake like</span></span></li></ol><div class="rich source code unison"><pre><code><span class="word">foo =
    id = "12345"
    firstName = "John"
    lastName = "Lennon"
    employee = Employee id (Name lastName firstName) (Date 1 1 1991)</span></code></pre></div><p><span class="span"><span class="word">(We've transposed the employees name!) Or even worse, maybe we accidentally swap the id and last name! However, the compiler would catch this problem.</span></span></p><div class="rich source code unison"><pre><code><span class="word">foo =
    id = EmployeeId "12345"
    firstName = FirstName "John"
    lastName = LastName "Lennon"
    employee = Employee id (Name lastName firstName) (Date 1 1 1991)
    ()</span></code></pre></div><div class="rich source code ucm"><pre><code><span class="word">The 1st argument to `Name`

            has type:  LastName
      but I expected:  FirstName

      9 | unique type LastName = LastName Text
     10 | unique type Name =
     11 |   { first: FirstName
      .
     23 |     employee = Employee id (Name lastName firstName) (Date 1 1 1991)</span></code></pre></div><p><span class="span"><span class="word">Of course, you can still make a mistake like</span></span></p><div class="rich source code unison"><pre><code><span class="word">firstName = LastName "Lennon"</span></code></pre></div><p><span class="span"><span class="word">But it's much harder to make this mistake. If we are ok with the extra types and the overhead of deconstructing them, we can catch many more typos/bugs at compile time, which means fewer tests are necessary to ensure correctness!</span></span></p><ol start="2"><li><span class="span"><span class="word">In the future, Unison may introduce the ability to make to make data constructors private and/or refined types. Doing so would allow us to to avoid another huge source of bugs when using primitive types directly, which is that the set of possible values is much larger than what we are attempting to model. You can see this in our model for</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Date</span></code></span><span class="word">:</span></span></span></span></li></ol><div class="rich source code unison"><pre><code><span class="word">unique type Date =
  { day: Nat
  , month: Nat
  , year: Nat
  }</span></code></pre></div><p><span class="span"><span class="word">By modeling day/month/year all as</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Nat</span></code></span><span class="word">we have introduced the possibility of an illegal state into our system. For example, in this model, we could have illegal dates like</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">0/500/99999999999999</span></code></span><span class="word">.</span></span></span><span class="word">In fact, lets try to restrict the possible values a bit, to reduce the surface area for future bugs. This means more tests and more runtime validation (and runtime validation failures).</span></span></p><p><span class="span"><span class="word">Lets try to contrain the possible values a bit.</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Date =
  { day: Day
  , month: Month
  , year: Year
  }
unique type Month
  = January
  | February
  | March
  | April
  | May
  | June
  | July
  | August
  | September
  | October
  | November
  | December
unique type Day = Day Nat
unique type Year = Year Nat</span></code></pre></div><p><span class="span"><span class="word">It is really easy for us to enumerate all of the possible months. We have eliminated the possiblity of an invalid month appearing in our system! Now we have to decide how far we want to go to make illegal state unrepresentable. Maybe</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Nat</span></code></span><span class="word">is ok for representing a year if we don't care about</span><span class="rich source inline-code"><code class="inline-code"><span class="word">BCE</span></code></span><span class="word">and we are ok with possibly talking about birthdays millions of years in the future (not ideal). But it would be nice to disallow days of months that don't exist, and this is where refined types, dependent types, or private constructors could be leveraged. Hopefully, we will have those one day!</span></span></p></section></section><section><h3 id="email"><span class="word">Email</span></h3><p><span class="span"><span class="word">Let's apply some similar decision making to get an Email.</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Email =
  { to: EmailAddress
  , subject: Subject
  , body: Body
  }

unique type EmailAddress = EmailAddress Text
unique type Subject = Subject Text
unique type Body = Body Text</span></code></pre></div><p><span class="span"><span class="word">Let's also update</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Employee</span></code></span><span class="word">to have an email address</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Employee =
  { id: EmployeeId
  , name: Name
  , birthday: Date
  , email: EmailAddress
  }</span></code></pre></div><p><span class="span"><span class="word">But maybe we can build a little bit toward the future here. The prompt told us the future will likely include sending birthday messages via other platforms, like SMS or robocalls.</span></span></p><p><span class="span"><span class="word">Maybe our model should actually be about a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Message</span></code></span><span class="word">of which there is some relationship with an</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Email</span></code></span><span class="word">.</span></span></span><span class="word">One possible way to model this would be</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Message
  = Email EmailAddress Subject Body</span></code></pre></div><p><span class="span"><span class="word">which would give us the option of extending it in the future as needed</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Message
  = Email EmailAddress Subject Body
  | SMS PhoneNumber Body
  | TwitterDM TwitterHandle Body</span></code></pre></div></section><section><h3 id="summary"><span class="word">Summary</span></h3><p><span class="span"><span class="word">There isn't one "best" way to model this, but this is one possible way:</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Employee =
  { id: EmployeeId
  , name: Name
  , birthday: Date
  }

unique type EmployeeId = EmployeeId Text
unique type FirstName = FirstName Text
unique type LastName = LastName Text
unique type Name =
  { first: FirstName
  , last: LastName
  }

unique type Date =
  { day: Day
  , month: Month
  , year: Year
  }
unique type Month
  = January
  | February
  | March
  | April
  | May
  | June
  | July
  | August
  | September
  | October
  | November
  | December
unique type Day = Day Nat
unique type Year = Year Nat

unique type Message
  = Email EmailAddress Subject Body

unique type EmailAddress = EmailAddress Text
unique type Subject = Subject Text
unique type Body = Body Text</span></code></pre></div></section></section><section><h2 id="abilities"><span class="word">Abilities</span></h2><p><span class="span"><span class="word">Now that we have our model, let's quickly talk about the effects/infrastructure we know we will need.</span></span></p><p><span class="span"><span class="word">One of the goals of this exercise (and generally working as a software engineer) is to decouple infrastructure from our business logic (which is often approximately the same thing as spearating pure and impure code). In OO we would use interfaces to define contracts and dependency inject in whatever implementations we need (be it Postgres, AWS, an in-memory store, mocks, etc).</span></span></p><p><span class="span"><span class="word">In Unison, we leverage Abilities (also called Algebraic Effects) to accomplish something similar. See</span><a href="https://www.unisonweb.org/docs/abilities/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">the abilities documentation</span></span></a><span class="word">for a more detailed overview of Abilities.</span></span></p><p><span class="span"><span class="word">In our case, let's limit ourselves to the following effects: sending a message, fetching employees from somewhere (a flat file, a db, an api, anything), and fetching the current date. For the sake of simplicity let's ignore an exception throwing ability (and failures in general) or any other abilities that may make sense to add in a real production system.</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique ability MessageService where
  send: Message -&gt; Message

unique ability EmployeeRepository where
  fetchAllByBirthday: (Day, Month) -&gt; [Employee]

unique ability Calendar where
  today: Date</span></code></pre></div><p><span class="span"><span class="word">Let's walk through what these abilities are doing:</span></span></p><ol start="1"><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">MessageService</span></code></span><span class="word">is an ability that provides the interface for a single command</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">send</span></code></span><span class="word">.</span></span></span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">send</span></code></span><span class="word">s</span></span></span><span class="word">type signature can be read as "a function that takes a message and returns a (same) message, requiring the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">MessageService</span></code></span><span class="word">ability."</span></span></li><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeRepository</span></code></span><span class="word">provides the interface</span><span class="rich source inline-code"><code class="inline-code"><span class="word">fetchAllByBirthday</span></code></span><span class="word">which takes a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Day</span></code></span><span class="word">and a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Month</span></code></span><span class="word">pair and returns a list of</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Employees</span></code></span><span class="word">,</span></span></span><span class="word">requiring the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeRepository</span></code></span><span class="word">ability.</span></span></li><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">Calendar</span></code></span><span class="word">provides the interface</span><span class="rich source inline-code"><code class="inline-code"><span class="word">today</span></code></span><span class="word">which is a function that takes no arguments and returns a</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Date</span></code></span><span class="word">,</span></span></span><span class="word">requiring the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Calendar</span></code></span><span class="word">ability.</span></span></li></ol><p><span class="span"><span class="word">Note that abilities</span></span></p><ol start="1"><li><span class="span"><span class="word">can provide multiple interfaces if we wanted</span></span></li></ol><div class="rich source code unison"><pre><code><span class="word">unique ability EmployeeRepository where
  fetchAllByBirthday: (Day, Month) -&gt; [Employee]
  fetchAll: [Employee]
  findById: EmployeeId -&gt; {Employee}</span></code></pre></div><ol start="2"><li><span class="span"><span class="word">have their behavior defined elsewhere (using handler syntax we will get to later)</span></span></li><li><span class="span"><span class="word">are composable (hence "algebraic effects")</span></span></li><li><span class="span"><span class="word">require that any calling function provide the ability in their type signature, which bubbles all the way to the top of the call stack (until it finds a handler).</span></span></li></ol><p><span class="span"><span class="word">So let's scaffold our main function for this exercise and see this stuff in action.</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails : [Message]
sendBirthdayEmails =
  todo "get the current date"
  todo "fetch all the employees with birthdays today"
  todo "create happy birthday messages"
  todo "send and return the messages"</span></code></pre></div><p><span class="span"><span class="word">Let's say we want a function we can call that will find all the employees whose birthday is today, create emails for them, send those emails, and then return those emails so we can see what was created and sent.</span></span></p><p><span class="span"><span class="word">As an aside, let's avoid modeling failures simply because it will clutter this exercise a bit. In real life, many of our effects would have type signatures with</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Either</span></code></span><span class="word">so we could model possible failures, but let's just naively pretend everything always works.</span></span></p><p><span class="span"><span class="word">So let's do some more scaffolding!</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails : [Message]
sendBirthdayEmails =
  today' = today
  employees = fetchAllByBirthday (Date.day today', Date.month today')
  messages = map (Employee.toBirthdayMessage) employees
  map (send) messages

Employee.toBirthdayMessage : Employee -&gt; Message
Employee.toBirthdayMessage _ = todo "toBirthdayMessage"</span></code></pre></div><p><span class="span"><span class="word">So we will grab the date, use that to fetch all the employees with birthdays today, map those employees to messages, and then send out (and return) those messages.</span></span></p><p><span class="span"><span class="word">Uh oh! The compiler is mad!</span></span></p><div class="rich source code ucm"><pre><code><span class="word">The expression in red needs the {Calendar} ability, but this location does not have access to any abilities.

    136 |   today' = today)</span></code></pre></div><p><span class="span"><span class="word">Ah, turns out that any function with an ability in its signature can only be called by another function with that ability available in its signature. So we need to add all our abilities to the function signature. So let's just go ahead and add all three.</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails : {MessageService, EmployeeRepository, Calendar} [Message]</span></code></pre></div><p><span class="span"><span class="word">But we are stil getting the same error. 🙁</span></span></p><p><span class="span"><span class="word">Well, it turns out that these effects can actually only be run in the context of a handler and they have to be in a function body. We should defer the computation with a thunk (so all effects become deferred) and then wire our handler up.</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails : '{MessageService, EmployeeRepository, Calendar} [Message]
sendBirthdayEmails =  'let
  today' = today
  employees = fetchAllByBirthday (Date.day today', Date.month today')
  messages = map (Employee.toBirthdayMessage) employees
  map (send) messages

Employee.toBirthdayMessage : Employee -&gt; Message
Employee.toBirthdayMessage _ = todo "toBirthdayMessage"</span></code></pre></div><p><span class="span"><span class="word">And the compiler seems happy so far! Note that we just deferred the entire computation by putting the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">'let</span></code></span><span class="word">at the beginning.</span></span></p><p><span class="span"><span class="word">Let's move on applying TDD in order to implement the remaining code.</span></span></p></section><section><h2 id="implementation"><span class="word">Implementation!</span></h2><p><span class="span"><span class="word">Let's write a first failing test!</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; sendBirthdayEmails.tests.noBirthdaysToday =
  check let
    actual = !sendBirthdayEmails
    expected = []
    if expected === actual
    then true
    else bug (exected, actual)</span></code></pre></div><div class="rich source code ucm"><pre><code><span class="word">The expression in red  needs these abilities: {Calendar, EmployeeRepository, MessageService}, but this location does not have access to any abilities.

     70 |     actual = !sendBirthdayEmails</span></code></pre></div><p><span class="span"><span class="word">Well we can't defer this call any more, this is the boundary of the system! So it's time to implement handlers for our abilities!</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; sendBirthdayEmails.tests.noBirthdaysToday =
  check let
    actual =
      handle
        handle
          handle
            !sendBirthdayEmails
          with (Calendar.handler.mock (Date (Day 1) January (Year 1991)))
        with (EmployeeRepository.handler.mock [])
      with MessageService.handler.mock
    expected = []
    if expected === actual
    then true
    else bug (expected, actual)

Calendar.handler.mock : Date -&gt; {Calendar} k -&gt; k
Calendar.handler.mock date k =
  h : Request {Calendar} k -&gt; k
  h = cases
    {today -&gt; resume} -&gt; handle resume date with h
    { resume } -&gt; resume
  handle k with h

EmployeeRepository.handler.mock : [Employee] -&gt; {EmployeeRepository} k -&gt; k
EmployeeRepository.handler.mock employees k =
  h : Request {EmployeeRepository} k -&gt; k
  h = cases
    { fetchAllByBirthday birthday -&gt; resume } -&gt;
      birthdays = filter (employee -&gt; (Date.day (Employee.birthday employee), Date.month (Employee.birthday employee)) === birthday) employees
      handle resume birthdays with h
    { resume } -&gt; resume
  handle k with h

MessageService.handler.mock : {MessageService} k -&gt; k
MessageService.handler.mock k =
  h : Request {MessageService} k -&gt; k
  h = cases
    { send message -&gt; resume } -&gt; handle resume message with h
    { resume } -&gt; resume
  handle k with h</span></code></pre></div><p><span class="span"><span class="word">This is a lot so lets dig into it a bit!</span></span></p><p><span class="span"><span class="word">The syntax for a handler is</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">handle &lt;fn&gt; with &lt;handler&gt;</span></code></span><span class="word">.</span></span></span><span class="word">I've wrapped our call to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">!sendBirthdayEmails</span></code></span><span class="word">in three nested handle blocks (we can make this cleaner later).</span></span></p><p><span class="span"><span class="word">When you write a handler, your goal is to pattern match on the possible ability function signatures, and then "resume" the computation (or not) along with providing the expected value for the ability. Let's dig in to our mock Calendar handler:</span></span></p><div class="rich source code unison"><pre><code><span class="word">Calendar.handler.mock : Date -&gt; {Calendar} k -&gt; k
Calendar.handler.mock date k =
  h : Request {Calendar} k -&gt; k
  h = cases
    {today -&gt; resume} -&gt; handle resume date with h
    { resume } -&gt; resume
  handle k with h</span></code></pre></div><ol start="1"><li><span class="span"><span class="word">our mock calendar handler dates a</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Date</span></code></span><span class="word">as input. This is so we can specify the return value of `today`, so we can "mock" it in our tests.</span></span></li><li><span class="span"><span class="word">the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">is the "continuation", our handler is being consulted to try to handle an ability, and then we call k to "continue" the existing computation.</span></span></li><li><span class="span"><span class="word">we define some handler</span><span class="rich source inline-code"><code class="inline-code"><span class="word">h</span></code></span><span class="word">locally which does the actual bulk of the work. It pattern matches on any ability operations we care about. Note that its signature has access to the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Calendar</span></code></span><span class="word">ability.</span></span></li><li><span class="span"><span class="word">we pattern match on two cases. The first is the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">today</span></code></span><span class="word">case. If we are handling the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">today</span></code></span><span class="word">method, all we are doing is handling the continuation (by calling resume) and providing the value for</span><span class="rich source inline-code"><code class="inline-code"><span class="word">today</span></code></span><span class="word">which is the provided</span><span class="rich source inline-code"><code class="inline-code"><span class="word">date</span></code></span><span class="word">since are just "mocking" the date in this handler. The continuation is called and handled recursively.</span></span></li><li><span class="span"><span class="word">we have a base</span><span class="rich source inline-code"><code class="inline-code"><span class="word">resume</span></code></span><span class="word">pattern where we are basically saying "if this handler encounters behavior which</span><span class="italic"><span class="word">doesn't</span></span><span class="word">call the ability operations, just bubble this result up to the caller."</span></span></li></ol><p><span class="span"><span class="word">In summary,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Calendar.handler.mock</span></code></span><span class="word">takes a</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">Date</span></code></span><span class="word">,</span></span></span><span class="word">and any function it handles that calls `today` will return that date.</span></span></p><p><span class="span"><span class="word">Now let's look at the</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeRepository</span></code></span><span class="word">:</span></span></span></span></p><div class="rich source code unison"><pre><code><span class="word">EmployeeRepository.handler.mock : [Employee] -&gt; {EmployeeRepository} k -&gt; k
EmployeeRepository.handler.mock employees k =
  h : Request {EmployeeRepository} k -&gt; k
  h = cases
    { fetchAllByBirthday birthday -&gt; resume } -&gt;
      birthdays = filter (employee -&gt; (Date.day (Employee.birthday employee), Date.month (Employee.birthday employee)) === birthday) employees
      handle resume birthdays with h
    { resume } -&gt; resume
  handle k with h</span></code></pre></div><p><span class="span"><span class="word">This is another mock to make it easy to test our program.</span></span></p><ol start="1"><li><span class="span"><span class="word">This handler takes a list of employees, which it uses to generate the return value for</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">fetchAllByBirthday</span></code></span><span class="word">.</span></span></span></span></li><li><span class="span"><span class="word">Our</span><span class="rich source inline-code"><code class="inline-code"><span class="word">h</span></code></span><span class="word">take a request with the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">EmployeeRepository</span></code></span><span class="word">ability.</span></span></li><li><span class="span"><span class="word">We match on the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">fetchAllByBirthday</span></code></span><span class="word">method and it's argument</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">birthday</span></code></span><span class="word">.</span></span></span></span></li><li><span class="span"><span class="word">When we match on that method, we filter the provided list of employees based on the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">birthday</span></code></span><span class="word">arg, and resume the computation with those employees as the return value.</span></span></li><li><span class="span"><span class="word">In real life, we might read from a DB here.</span></span></li><li><span class="span"><span class="word">Otherwise we bubble up the function in case other handlers know how to handle it.</span></span></li></ol><p><span class="span"><span class="word">And finally</span></span></p><div class="rich source code unison"><pre><code><span class="word">MessageService.handler.mock : {MessageService} k -&gt; k
MessageService.handler.mock k =
  h : Request {MessageService} k -&gt; k
  h = cases
    { send message -&gt; resume } -&gt; handle resume message with h
    { resume } -&gt; resume
  handle k with h</span></code></pre></div><ol start="1"><li><span class="span"><span class="word">This handler does not take any args because it doesn't need any outside info to handle the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">send</span></code></span><span class="word">function.</span></span></li><li><span class="span"><span class="word">We match on the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">send</span></code></span><span class="word">function and its message argument and resume the computation with that same message as a return value</span></span></li><li><span class="span"><span class="word">A real version of this might instead reach out to Twilio or some external service to perform an effect before continuing.</span></span></li><li><span class="span"><span class="word">And we bubble up any functions we don't care about.</span></span></li></ol><p><span class="span"><span class="word">Great! And then we just wrap all these handlers around our birthday function.</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; sendBirthdayEmails.tests.noBirthdaysToday =
  check let
    actual =
      handle
        handle
          handle
            !sendBirthdayEmails
          with (Calendar.handler.mock (Date (Day 1) January (Year 1991)))
        with (EmployeeRepository.handler.mock [])
      with MessageService.handler.mock
    expected = []
    if expected === actual
    then true
    else bug (expected, actual)</span></code></pre></div><p><span class="span"><span class="word">And thats how we do "dependency injection" in unison! We can easily swap out these handlers with other behaviors at the boundary of our system!</span></span></p><p><span class="span"><span class="word">Now that we have a passing test, let's take a minute to refactor a bit before we add some more interesting test cases.</span></span></p><p><span class="span"><span class="word">All these nested handlers are kind of gross. Let's combine them into a single "multihandler".</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails.handlers.mock : Date -&gt; [Employee] -&gt; '{Calendar, EmployeeRepository, MessageService} k -&gt; k
sendBirthdayEmails.handlers.mock date employees k =
  h : Request {Calendar, EmployeeRepository, MessageService} k -&gt; k
  h = cases
    {today -&gt; resume} -&gt; handle resume date with h
    { send message -&gt; resume } -&gt; handle resume message with h
    { fetchAllByBirthday birthday -&gt; resume } -&gt;
      birthdays = filter (employee -&gt; (Date.day (Employee.birthday employee), Date.month (Employee.birthday employee)) === birthday) employees
      handle resume birthdays with h
    { resume } -&gt; resume
  handle !k with h

test&gt; sendBirthdayEmails.tests.noBirthdaysToday =
  check let
    today = Date (Day 1) January (Year 2021)
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today []
    expected = []
    if expected === actual
    then true
    else bug (expected, actual)</span></code></pre></div><p><span class="span"><span class="word">Note that we have changed how we use the handlers to something slightly more idiomatic: a normal function call! I've chosen to pipe in the function as the last argument because I think it puts the "important" bit at the beginning of the line.</span></span></p><p><span class="span"><span class="word">Note (again) that we updated the handler's signature to defer the first</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">so we no longer need to add</span><span class="rich source inline-code"><code class="inline-code"><span class="word">!</span></code></span><span class="word">to the top level test since it is done inside the handler.</span></span></p><p><span class="span"><span class="word">Alright let's test with the next test case, a single birthday today!</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; sendBirthdayEmails.tests.oneBirthdayToday =
  check let
    employees =
      [
        Employee
        (EmployeeId "1")
        (Name (FirstName "John") (LastName "Smith"))
        (Date (Day 1) January (Year 1991))
        (EmailAddress "john@smith.com")
      , Employee
        (EmployeeId "2")
        (Name (FirstName "Fred") (LastName "Smith"))
        (Date (Day 2) March (Year 1991))
        (EmailAddress "fred@smith.com")
      ]
    today = Date (Day 1) January (Year 2021)
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today employees

    expected =
      [
        Email
        (EmailAddress "john@smith.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      ]
    if expected === actual
    then true
    else bug (expected, actual)</span></code></pre></div><div class="rich source code ucm"><pre><code><span class="word">💔💥

  I've encountered a call to builtin.todo with the following value:

    "toBirthdayMessage"</span></code></pre></div><p><span class="span"><span class="word">That's a good failure! Let's fix it!</span></span></p><div class="rich source code unison"><pre><code><span class="word">Employee.toBirthdayMessage : Employee -&gt; Message
Employee.toBirthdayMessage employee =
  Email (Employee.email employee) (Subject "Happy Birthday!") (Body "Congrats! Love, HR.")</span></code></pre></div><div class="rich source code ucm"><pre><code><span class="word">70 |   check let

    ✅ Passed : Proved.

    81 |   check let

    ✅ Passed : Proved.</span></code></pre></div><p><span class="span"><span class="word">It's working! Let's do one more test case just to be sure.</span></span></p><div class="rich source code unison"><pre><code><span class="word">test&gt; sendBirthdayEmails.tests.twoBirthdaysToday =
  check let
    employees =
      [
        Employee
        (EmployeeId "1")
        (Name (FirstName "John") (LastName "Smith"))
        (Date (Day 1) January (Year 1991))
        (EmailAddress "john@smith.com")
      , Employee
        (EmployeeId "2")
        (Name (FirstName "Fred") (LastName "Smith"))
        (Date (Day 2) March (Year 1991))
        (EmailAddress "fred@smith.com")
      , Employee
        (EmployeeId "3")
        (Name (FirstName "Abe") (LastName "Lincoln"))
        (Date (Day 2) March (Year 1776))
        (EmailAddress "abe@lincoln.com")
      ]
    today = Date (Day 2) March (Year 2021)
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today employees

    expected =
      [
        Email
        (EmailAddress "fred@smith.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      , Email
        (EmailAddress "abe@lincoln.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      ]
    if expected === actual
    then true
    else bug (expected, actual)</span></code></pre></div><div class="rich source code ucm"><pre><code><span class="word">70 |   check let

    ✅ Passed : Proved.

    81 |   check let

    ✅ Passed : Proved.

    113 |   check let

    ✅ Passed : Proved.</span></code></pre></div><p><span class="span"><span class="word">Great! And of course there many more tests you can add to make sure this is working for various corner cases, but this seems pretty good for now!</span></span></p><p><span class="span"><span class="word">So let's go back and refactor our main function a bit now that we have the stability of some tests.</span></span></p><div class="rich source code unison"><pre><code><span class="word">sendBirthdayEmails : '{Calendar, EmployeeRepository, MessageService} [Message]
sendBirthdayEmails =  'let
  today
    |&gt; toDayMonthPair
    |&gt; fetchAllByBirthday
    |&gt; toBDayMessages
    |&gt; sendAll

toDayMonthPair : Date -&gt; (Day, Month)
toDayMonthPair = cases
  Date day month _ -&gt; (day, month)

toBDayMessages : [Employee] -&gt; [Message]
toBDayMessages employees =
  map (Employee.toBirthdayMessage) employees

sendAll : [Message] -&gt;{MessageService} [Message]
sendAll messages =
  map (send) message</span></code></pre></div><p><span class="span"><span class="word">Looks a lot cleaner, its easier to read, and its composed of a bunch of small modular easy to understand functions!</span></span></p></section><section><h2 id="conclusion"><span class="word">Conclusion</span></h2><p><span class="span"><span class="word">Let's see it all together!</span></span></p><div class="rich source code unison"><pre><code><span class="word">unique type Employee =
  { id: EmployeeId
  , name: Name
  , birthday: Date
  , email: EmailAddress
  }

unique type EmployeeId = EmployeeId Text
unique type FirstName = FirstName Text
unique type LastName = LastName Text
unique type Name =
  { first: FirstName
  , last: LastName
  }

unique type Date =
  { day: Day
  , month: Month
  , year: Year
  }
unique type Month
  = January
  | February
  | March
  | April
  | May
  | June
  | July
  | August
  | September
  | October
  | November
  | December
unique type Day = Day Nat
unique type Year = Year Nat

unique type Message
  = Email EmailAddress Subject Body

unique type EmailAddress = EmailAddress Text
unique type Subject = Subject Text
unique type Body = Body Text

unique ability MessageService where
  send: Message -&gt; Message

unique ability EmployeeRepository where
  fetchAllByBirthday: (Day, Month) -&gt; [Employee]

unique ability Calendar where
  today: Date

sendBirthdayEmails : '{Calendar, EmployeeRepository, MessageService} [Message]
sendBirthdayEmails =  'let
  today
    |&gt; toDayMonthPair
    |&gt; fetchAllByBirthday
    |&gt; toBDayMessages
    |&gt; sendAll

toDayMonthPair : Date -&gt; (Day, Month)
toDayMonthPair = cases
  Date day month _ -&gt; (day, month)

toBDayMessages : [Employee] -&gt; [Message]
toBDayMessages employees =
  map Employee.toBirthdayMessage employees

sendAll : [Message] -&gt;{MessageService} [Message]
sendAll messages =
  map send messages

Employee.toBirthdayMessage : Employee -&gt; Message
Employee.toBirthdayMessage employee =
  Email (Employee.email employee) (Subject "Happy Birthday!") (Body "Congrats! Love, HR.")

sendBirthdayEmails.handlers.mock : Date -&gt; [Employee] -&gt; '{Calendar, EmployeeRepository, MessageService} k -&gt; k
sendBirthdayEmails.handlers.mock date employees k =
  h : Request {Calendar, EmployeeRepository, MessageService} k -&gt; k
  h = cases
    {today -&gt; resume} -&gt; handle resume date with h
    { send message -&gt; resume } -&gt; handle resume message with h
    { fetchAllByBirthday birthday -&gt; resume } -&gt;
      birthdays = filter (employee -&gt; (Date.day (Employee.birthday employee), Date.month (Employee.birthday employee)) === birthday) employees
      handle resume birthdays with h
    { resume } -&gt; resume
  handle !k with h

test&gt; sendBirthdayEmails.tests.noBirthdaysToday =
  check let
    today = Date (Day 1) January (Year 2021)
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today []
    expected = []
    if expected === actual
    then true
    else bug (expected, actual)

test&gt; sendBirthdayEmails.tests.oneBirthdayToday =
  check let
    employees =
      [
        Employee
        (EmployeeId "1")
        (Name (FirstName "John") (LastName "Smith"))
        (Date (Day 1) January (Year 1991))
        (EmailAddress "john@smith.com")
      , Employee
        (EmployeeId "2")
        (Name (FirstName "Fred") (LastName "Smith"))
        (Date (Day 2) March (Year 1991))
        (EmailAddress "fred@smith.com")
      ]
    today = Date (Day 1) January (Year 2021))
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today employees

    expected =
      [
        Email
        (EmailAddress "john@smith.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      ]
    if expected === actual
    then true
    else bug (expected, actual)

test&gt; sendBirthdayEmails.tests.twoBirthdaysToday =
  check let
    employees =
      [
        Employee
        (EmployeeId "1")
        (Name (FirstName "John") (LastName "Smith"))
        (Date (Day 1) January (Year 1991))
        (EmailAddress "john@smith.com")
      , Employee
        (EmployeeId "2")
        (Name (FirstName "Fred") (LastName "Smith"))
        (Date (Day 2) March (Year 1991))
        (EmailAddress "fred@smith.com")
      , Employee
        (EmployeeId "3")
        (Name (FirstName "Abe") (LastName "Lincoln"))
        (Date (Day 2) March (Year 1776))
        (EmailAddress "abe@lincoln.com")
      ]
    today = Date (Day 2) March (Year 2021)
    actual = sendBirthdayEmails |&gt; sendBirthdayEmails.handlers.mock today employees

    expected =
      [
        Email
        (EmailAddress "fred@smith.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      , Email
        (EmailAddress "abe@lincoln.com")
        (Subject "Happy Birthday!")
        (Body "Congrats! Love, HR.")
      ]
    if expected === actual
    then true
    else bug (expected, actual)</span></code></pre></div></section><section><h2 id="references"><span class="word">References</span></h2><p><a href="https://www.youtube.com/watch?v=Up7LcbGZFuo&amp;ab_channel=NDCConferences" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Scott Wlaschin - Domain Modeling Made Functional</span></span></a></p><p><a href="https://www.youtube.com/watch?v=cxs7oLGrxQ4" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Mark Seemann - Dependency Injection to Dependency Rejection</span></span></a></p><p><a href="https://www.youtube.com/watch?v=US8QG9I1XW0&amp;ab_channel=NDCConferences" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Mark Seemann - Pits of Success</span></span></a></p><p><a href="https://unisonlanguage.slack.com/archives/CLKV43YE4/p1624391625329100?thread_ts=1624385627.328200&amp;cid=CLKV43YE4" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Unison slack thread that contributed a lot of code examples</span></span></a></p></section><section><h2 id="get-in-touch"><span class="span"><span class="word">Get In Touch</span></span></h2><p><span class="span"><span class="word">If you've been working on a Unison project or have a programming topic you'd like to explore in Unison, we want to hear from you! Email</span><a href="mailto:community@unison.cloud" class="named-link" rel="noopener" target="_self"><span class="word">community@unison.cloud</span></a><span class="word">and we'll help you get published here.</span></span></p></section></section></section><div class="tooltips" style="display: none;"></div></article>
{% endraw %}
