---
tags: whats-new
layout: whats-new-post.njk
permalink: whats-new/jit-announce/index.html
summary: ""
featuredImage: /assets/thing15.svg
categories:
  - news
authors:
  - Dan Doel
date: 2022-03-28T00:00:00.000Z
title: "JIT compilation is coming to Unison: an early progress report"
---

{% raw %}
<article class="unison-doc"><section><p></p><section><p><span class="span"><span class="word">In the past couple weeks, I've been working on a new method of compiling unison programs to native code. Unison already has a way of</span><a href="https://www.unison-lang.org/learn/at-a-glance/#hello-world" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">packaging a standalone program</span></span></a><span class="word">into a binary file that starts up very quickly, but that still uses the same interpreter written in Haskell. While the interpreter is written to be reasonably efficient given optimized intermediate code, unfortunately there hasn't been an opportunity to spend a significant amount of time on optimizations that would realize its full potential. Also, even in the best case, an interpreter will always have significant overhead compared to native code.</span></span></p><p><span class="span"><span class="word">Thus, compiling to native code seems like an inevitable step. There are several considerations that would make a target more or less suitable/convenient:</span></span></p><ol start="1"><li><span class="span"><span class="word">The compilation has to have the ability to work just-in-time. It's okay to be able to precompile binaries from known code, but one of the primary uses we have for the standalone binaries right now is to implement a server that evaluates unison code sent to it from another environment. That code is not known ahead of time; it is serialized and sent from the client, and needs to be deserialized, compiled and executed on the server.</span></span></li><li><span class="span"><span class="word">Tail calls need to be handled properly. Theyâ€™re</span><a href="https://eighty-twenty.org/2011/10/01/oo-tail-calls" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">a useful feature in any language</span></span></a><span class="word">but in Unison theyâ€™re also the only mechanism for writing loops.</span></span></li><li><span class="span"><span class="word">Ideally, the target would support delimited continuations as an implementation of abilities. There are ways of implementing algebraic effects without delimited continuations, but continuations are a better match (I'll explain further on).</span></span></li><li><span class="span"><span class="word">It would be advantageous if the target already had a reasonable implementation of various low level compilation details. Unison isn't really novel in ways that would require a specialized garbage collector or native code generator, so it would be good if we can avoid needing to implement these things from scratch.</span></span></li><li><span class="span"><span class="word">The runtime should be capable of doing some relatively sophisticated things. Right now Unison wraps features of GHC's runtime, like lightweight threads with asynchronous I/O, and software transactional memory. Ideally it wouldn't be necessary to completely reimplement these features.</span></span></li></ol><p><span class="span"><span class="word">Based on these considerations, we decided that a</span><a href="https://cisco.github.io/ChezScheme/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Chez Scheme</span></span></a><span class="word">backend was a promising direction. Scheme and Lisp in general are well known for supporting dynamic code loading features, and well behaved tail calls are one of the defining features of Scheme. Continuations are also heavily associated with scheme, so it's likely that most implementations would be well equipped in that area, too. Since it's meant to be usable as a functional language in its own right, it has garbage collection and reasonable library capabilities. Moreover it seems to be fairly well equipped as far as generating code for functional languages goes.</span></span></p><p><span class="span"><a href="https://jaredforsyth.com/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Jared Forsyth</span></span></a><span class="word">did some early prototyping of a compilation to Scheme pipeline and was getting some nice results compiling pure code, and that really inspired us to look more closely at Scheme as a serious target. We also knew that the rewrite of</span><a href="https://www.idris-lang.org/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">the Idris language</span></span></a><span class="word">had initially based its backend on Chez (although I think it has several backends again at this point). But when researching, I also discovered that</span><a href="https://racket-lang.org/" class="named-link" rel="noopener" target="_blank"><span class="word">Racket</span></a><span class="word">has been moving toward</span><a href="https://www.cs.utah.edu/plt/publications/icfp19-rddkmstz.pdf" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">replacing its backend</span></span></a><span class="word">with Chez as well. The Racket report specifically suggests that Chez could be a better target for functional languages than a lot of other common compiler backends, since many of the latter have limitations based around the needs of more traditional imperative languages.</span></span></p><div class="callout callout-with-icon"><div class="callout-icon">ðŸ¤”</div><div class="callout-content"><section><p><strong><span class="span"><span class="word">What about LLVM?</span></span></strong></p><p><span class="span"><span class="word">For a high-level functional language like Unison, LLVM is pretty low-level as a compilation target. It provides something like a platform independent assembly language, saving you from needing to write a register allocator and native code generator. LLVM can also support tail calls provided you use one of the</span><span class="group"><span class="join"><a href="https://llvm.org/docs/CodeGenerator.html#tail-call-optimization" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">right calling conventions</span></span></a><span class="word">.</span></span></span></span></p><p><span class="span"><span class="word">It doesn't provide any runtime services out of the box, such as a garbage collector, continuations and/or delimited continuations, lightweight threads, async I/O, etc, which means it can be a considerable amount of work to build a serious LLVM-based JIT with these features.</span></span></p></section></div></div><p><span class="span"><span class="word">Probably the most significant gap in the capabilities of the Chez runtime is software transactional memory. Unsurprisingly (since it's very difficult to use correctly without an effect checking system), Chez doesn't implement it. Glancing at</span><span class="group"><span class="join"><a href="https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">the original STM paper for GHC</span></span></a><span class="word">,</span></span></span><span class="word">the implementation they describe doesn't sound</span><span class="italic"><span class="word">too</span></span><span class="word">difficult, and looks doable using the concurrency primitives present in Chez.</span></span></p><section><h2 id="whats-working-so-far"><span class="span"><span class="word">What's working so far</span></span></h2><p><span class="span"><span class="word">So far, I've written (part of) a compiler from one of the existing intermediate code representations to Scheme code. The intermediate representation uses</span><a href="https://en.wikipedia.org/wiki/A-normal_form" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">A-normal form</span></span></a><span class="word">with nested pattern matching desugared to single level matching and all local function definitions floated to an outer-most recursive let block for each top level definition. This level of normalization is not all completely necessary for compilation to Scheme, but it is the format we're already using to send code between Unison instances, so it would need to be handled anyway.</span></span></p><p><span class="span"><span class="word">I started by writing the Scheme emitter in Haskell using the existing data structures there. But after some discussion, Paul and I realized that in order for the dynamic loading of Unison code to work in a program compiled to Scheme, it'd be necessary to have the compilation from Unison to Scheme available in Scheme itself. One option is to just write it directly in Scheme, but another option is to write it in Unison, which is then compiled to Scheme. This is what I've done most recently: I have a version of the intermediate data structures defined as Unison data types, along with ways of parsing the binary format for code interchange into those Unison types, and a compiler that emits Scheme definitions from those. Right now it is rather limited, only supporting pure code and a few arithmetic builtins, but it is possible to compile those Unison definitions to Scheme just by running a Unison program. For instance, if we define:</span></span></p><div class="rich source code unison"><pre><code><span class="word">codeTest : '{IO,Exception} ()
codeTest _ = printScheme (termLink addMain)</span></code></pre></div><p><span class="span"><span class="word">And execute</span><span class="rich source inline-code"><code class="inline-code"><span class="word">run codeTest</span></code></span><span class="word">at the prompt, we get output ending with:</span></span></p><div class="rich source code scheme"><pre><code><span class="word">(define-unison
  (ref-3YXYAR7AJAIUWLOQDTCM4VL3FYDCHJ x1)
  (letrec-unison
    ([(x0 x1)
      (let* ([x2 10000000]
             [x3 (identity x2)])
        (ref-M5Y65PHZ3GWHMCUMIJ3LGLBLKPSYMA x3))])
    (let* ([x2 100]
           [x3 (identity x2)]
           [x4 (x0)])
      (ref-ZQRWH24DGQ437B72KCOZXGRZAJJW2U x3 x4))))

(ref-3YXYAR7AJAIUWLOQDTCM4VL3FYDCHJ #f)</span></code></pre></div><p><span class="span"><span class="word">The full Unison API for code loading requires a fair bit more than just this sort of code generation, but it's an important component. Unfortunately I haven't yet filled in enough primitive operations to be able to compile the compiler itself to Scheme. The above code comes from a nested loop that prints the sum of the numbers from 0 to 10 million 100 times. Using the compiled scheme code is around</span><strong><span class="span"><span class="word">470x faster</span></span></strong><span class="word">than our current interpreter, at least for this simple arithmetic loop.</span></span></p><p><span class="span"><span class="word">While we could produce much better intermediate code for our interpreter by applying standard optimizations (such as worker/wrapper transformations, inlining, etc), Scheme is providing great performance with our more naive intermediate code, presumably because</span><a href="https://twitter.com/edwinbrady/status/1389212471513190401" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">it already does</span></span></a><span class="word">many of these optimizations itself.</span></span></p></section><section><h2 id="implementing-abilities"><span class="span"><span class="word">Implementing abilities</span></span></h2><p><span class="span"><span class="word">One major piece currently missing is the implementation of the primitives for abilities. As alluded to above, the way abilities work in the intermediate code and interpreter is based on delimited continuations. This section walks through some of the technical details of this but feel free to skip ahead.</span></span></p><p><span class="span"><span class="word">Scheme is well known for its support of continuations. However, the sort in the (R6RS) Scheme standard are not the ones we want. They are based around the operation</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">call-with-current-continuation</span></code></span><span class="word">,</span></span></span><span class="word">which I'll abbreviate to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">going forward. The idea is that if we write:</span></span></p><div class="rich source code scheme"><pre><code><span class="word">(call/cc (lambda (k) ...))</span></code></pre></div><p><span class="span"><span class="word">Then the lambda expression gets called with a special function that has captured the control flow context leading up to that point in the program. The lambda expression may return normally, in which case its result is supplied to that context. However, calling</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="italic"><span class="word">also</span></span><span class="word">causes the program to act like the argument to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">was returned from the lambda expression. This is true even if</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">escapes the scope of the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">block, which means that it has the power to</span><span class="italic"><span class="word">replace</span></span><span class="word">the entire remaining control flow context anywhere in the program.</span></span></p><p><span class="span"><span class="word">An ability handler clearly involves a continuation as well. A pattern match implementing one looks something like:</span></span></p><div class="rich source code unison"><pre><code><span class="word">{ E x y z -&gt; k } -&gt; ...</span></code></pre></div><p><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">being the continuation again. However, these continuations behave much more like functions. Calling</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">does not completely replace the execution context, but adds to it like a normal function. It's possible that</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">would have captured some</span><span class="rich source inline-code"><code class="inline-code"><span class="word">Exception</span></code></span><span class="word">effects that</span><span class="italic"><span class="word">would</span></span><span class="word">jump to a top-level handler, but this is also no different from functions, and those effects can be handled so that they don't escape.</span></span></p><p><span class="span"><span class="word">This is where</span><span class="italic"><span class="word">delimited</span></span><span class="word">continuations come in. They are instead based around a</span><span class="italic"><span class="word">pair</span></span><span class="word">of operations, the simplest of which are</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">.</span></span></span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">is similar to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">,</span></span></span><span class="word">and a use would look something like:</span></span></p><div class="rich source code scheme"><pre><code><span class="word">(shift (lambda (k) ...))</span></code></pre></div><p><span class="span"><span class="word">There are three primary differences:</span></span></p><ol start="1"><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">only captures into</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">a portion of the control flow context, limited by the nearest enclosing</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">.</span></span></span></span></li><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">actually behaves like a function. To know what</span><span class="rich source inline-code"><code class="inline-code"><span class="word">(k x)</span></code></span><span class="word">does, imagine if</span><span class="rich source inline-code"><code class="inline-code"><span class="word">x</span></code></span><span class="word">were returned from the original</span><span class="rich source inline-code"><code class="inline-code"><span class="word">(shift ...)</span></code></span><span class="word">expression, and trace the execution until you find the value</span><span class="rich source inline-code"><code class="inline-code"><span class="word">y</span></code></span><span class="word">that would be returned from the enclosing</span><span class="rich source inline-code"><code class="inline-code"><span class="word">(reset ...)</span></code></span><span class="word">expression. Then</span><span class="rich source inline-code"><code class="inline-code"><span class="word">(k x)</span></code></span><span class="word">evaluates to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">y</span></code></span><span class="word">.</span></span></span><div class="folded is-folded"><div class="fold-toggle"><div class="icon icon-caret-right"><svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.08984 9.85306C4.08984 10.2398 4.51004 10.4801 4.84335 10.284L9.53902 7.52188C9.86767 7.32855 9.86767 6.85327 9.53902 6.65994L4.84335 3.89779C4.51004 3.70172 4.08984 3.94204 4.08984 4.32875V9.85306Z" fill="currentColor"></path>
</svg>
</div></div><div class="folded-content"><div class="folded-summary"><span class="span"><span class="word">Here is a concrete example.</span></span></div><div class="folded-details"><div><span class="span"><span class="word">Here is a concrete example.</span></span></div><section><p><span class="span"><span class="word">Consider the expression:</span></span></p><div class="rich source code raw"><pre><code><span class="word">    (+ 1 2
      (reset
        (+ 1
           2
           (shift (lambda (k) (k (k 5))))
           3)))
</span></code></pre></div><p><span class="span"><span class="word">This evaluates to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">20</span></code></span><span class="word">,</span></span></span><span class="word">because the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">captured is essentially the inner addition, meaning it's equivalent to:</span></span></p><div class="rich source code raw"><pre><code><span class="word">    (let ((f (lambda (x) (+ 1 2 x 3))))
      (+ 1 2 (f (f 5))))
</span></code></pre></div><p><span class="span"><span class="word">If the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">is replaced with</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">(removing the redundant</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">),</span></span></span><span class="word">then the result is</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">14</span></code></span><span class="word">,</span></span></span><span class="word">because it is equivalent to:</span></span></p><div class="rich source code raw"><pre><code><span class="word">    (+ 1 2 (+ 1 2 5 3))
</span></code></pre></div><p><span class="span"><span class="word">If you want, you can also try using delimited continuations in Unison.</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">is the effect part, introduced by the ability:</span></span></p><div class="folded-sources"><div class="folded rich source"><div class="fold-toggle"><div class="icon icon-caret-right"><svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.08984 9.85306C4.08984 10.2398 4.51004 10.4801 4.84335 10.284L9.53902 7.52188C9.86767 7.32855 9.86767 6.85327 9.53902 6.65994L4.84335 3.89779C4.51004 3.70172 4.08984 3.94204 4.08984 4.32875V9.85306Z" fill="currentColor"></path>
</svg>
</div></div><div class="folded-content"><div class="folded-summary"><pre><code><span class="syntax"><span class="data-type-modifier">structural</span><span class="blank"> </span><span class="data-type-keyword">ability</span><span class="blank"> </span><span class="hash-qualifier">Shift</span><span class="blank"> </span><span class="data-type-params">r</span></span></code></pre></div><div class="folded-details"><pre><code><span class="syntax"><span class="data-type-modifier">structural</span><span class="blank"> </span><span class="data-type-keyword">ability</span><span class="blank"> </span><span class="hash-qualifier">Shift</span><span class="blank"> </span><span class="data-type-params">r</span><span class="control-keyword"> where</span><span class="blank">
</span><span class="blank">  </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug@a0" target="_blank" class="term-reference">shift</a><span class="type-ascription-colon"> :</span><span class="blank"> </span><span class="blank">(</span><span class="blank">(</span><span class="var">a</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">r</span><span class="blank">)</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">r</span><span class="blank">)</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug" target="_blank" class="type-reference">Shift</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">a</span></span></code></pre></div></div></div></div><p><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">is the handler part, definable via:</span></span></p><div class="folded-sources"><div class="folded rich source"><div class="fold-toggle"><div class="icon icon-caret-right"><svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.08984 9.85306C4.08984 10.2398 4.51004 10.4801 4.84335 10.284L9.53902 7.52188C9.86767 7.32855 9.86767 6.85327 9.53902 6.65994L4.84335 3.89779C4.51004 3.70172 4.08984 3.94204 4.08984 4.32875V9.85306Z" fill="currentColor"></path>
</svg>
</div></div><div class="folded-content"><div class="folded-summary"><pre><code><span class="syntax"><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@l6sv51t219kaivun4nmjl5ek3fb6d0uaqkh62c9lupecj161e6ppuv8klueo58m9t5goj3joaj9frfcb0sf6j58ik9nsur1ab0nk7uo" target="_blank" class="term-reference"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">reset</span></span></a><span class="blank"> </span><span class="type-ascription-colon">: </span><span class="delay-force-char">'</span><span class="ability-braces">{</span><span class="var">e</span><span class="blank">,</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug" target="_blank" class="type-reference">Shift</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><span class="var">e</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span></span></code></pre></div><div class="folded-details"><pre><code><span class="syntax"><span class="hash-qualifier"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">reset</span></span></span><span class="type-ascription-colon"> :</span><span class="blank"> </span><span class="delay-force-char">'</span><span class="ability-braces">{</span><span class="var">e</span><span class="blank">,</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug" target="_blank" class="type-reference">Shift</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><span class="var">e</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank">
</span><span class="hash-qualifier"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">reset</span></span></span><span class="blank"> </span><span class="var">e</span><span class="binding-equals"> =</span><span class="blank">
</span><span class="blank">  </span><span class="hash-qualifier">h</span><span class="binding-equals"> =</span><span class="blank"> </span><span class="control-keyword">cases</span><span class="blank">
</span><span class="blank">  </span><span class="blank">  </span><span class="delimeter-char">{</span><span class="blank"> </span><span class="var">x</span><span class="blank"> </span><span class="delimeter-char">}</span><span class="blank">          </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">x</span><span class="blank">
</span><span class="blank">  </span><span class="blank">  </span><span class="delimeter-char">{</span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug@a0" target="_blank" class="term-reference">shift</a><span class="blank"> </span><span class="var">e</span><span class="blank"> </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">k</span><span class="delimeter-char">}</span><span class="blank"> </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">e</span><span class="blank"> </span><span class="parenthesis">(</span><span class="blank">x</span><span class="control-keyword"><span class="arrow"> -&gt;</span></span><span class="blank"> </span><span class="parenthesis">(</span><span class="control-keyword">handle</span><span class="blank"> </span><span class="var">k</span><span class="blank"> </span><span class="var">x</span><span class="blank"> </span><span class="control-keyword">with</span><span class="blank"> </span><span class="var">h</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="blank">
</span><span class="blank">  </span><span class="control-keyword">handle</span><span class="blank"> </span><span class="delay-force-char">!</span><span class="var">e</span><span class="blank"> </span><span class="control-keyword">with</span><span class="blank"> </span><span class="var">h</span></span></code></pre></div></div></div></div><p><span class="span"><span class="word">Then we can try the above example:</span></span></p><div class="source rich eval"><pre><code><div><span class="syntax"><span class="hash-qualifier">v</span><span class="binding-equals"> =</span><span class="blank">
</span><span class="blank">  </span><span class="use-keyword">use </span><span class="use-prefix">Nat</span><span class="blank"> </span><span class="use-suffix">+</span><span class="blank">
</span><span class="blank">  </span><span class="numeric-literal">1</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@@Nat.+" target="_blank" class="term-reference">+</a><span class="blank"> </span><span class="numeric-literal">2</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@@Nat.+" target="_blank" class="term-reference">+</a><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@l6sv51t219kaivun4nmjl5ek3fb6d0uaqkh62c9lupecj161e6ppuv8klueo58m9t5goj3joaj9frfcb0sf6j58ik9nsur1ab0nk7uo" target="_blank" class="term-reference"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">reset</span></span></a><span class="blank"> </span><span class="delay-force-char">'</span><span class="parenthesis">(</span><span class="numeric-literal">1</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@@Nat.+" target="_blank" class="term-reference">+</a><span class="blank"> </span><span class="numeric-literal">2</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@@Nat.+" target="_blank" class="term-reference">+</a><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@6tj468n4ukb0nm93rvebaj4rv2aov6h5414hbd6u97lobnpv7rhbshsklm10f11k9s29spuot17gi545bo663qi2jqb8f0p5neg7pug@a0" target="_blank" class="term-reference">shift</a><span class="blank"> </span><span class="parenthesis">(</span><span class="blank">k</span><span class="control-keyword"><span class="arrow"> -&gt;</span></span><span class="blank"> </span><span class="var">k</span><span class="blank"> </span><span class="parenthesis">(</span><span class="var">k</span><span class="blank"> </span><span class="numeric-literal">5</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@@Nat.+" target="_blank" class="term-reference">+</a><span class="blank"> </span><span class="numeric-literal">3</span><span class="parenthesis">)</span><span class="blank">
</span><span class="var">v</span></span><div class="result">â§¨<div><span class="syntax"><span class="numeric-literal">20</span></span></div></div></div></code></pre></div><p><span class="span"><span class="word">One thing to notice is that these operations use a "deep" handler. Shallow handlers actually correspond more closely to another pair of operations known as</span><span class="rich source inline-code"><code class="inline-code"><span class="word">control</span></code></span><span class="word">(similar to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">)</span></span></span><span class="word">and</span><span class="rich source inline-code"><code class="inline-code"><span class="word">prompt</span></code></span><span class="word">(similar to</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">).</span></span></span><span class="word">A Unison version of these might be defined something like:</span></span></p><div class="folded-sources"><div class="folded rich source"><div class="fold-toggle"><div class="icon icon-caret-right"><svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.08984 9.85306C4.08984 10.2398 4.51004 10.4801 4.84335 10.284L9.53902 7.52188C9.86767 7.32855 9.86767 6.85327 9.53902 6.65994L4.84335 3.89779C4.51004 3.70172 4.08984 3.94204 4.08984 4.32875V9.85306Z" fill="currentColor"></path>
</svg>
</div></div><div class="folded-content"><div class="folded-summary"><pre><code><span class="syntax"><span class="data-type-modifier">structural</span><span class="blank"> </span><span class="data-type-keyword">ability</span><span class="blank"> </span><span class="hash-qualifier">Control</span><span class="blank"> </span><span class="data-type-params">r</span></span></code></pre></div><div class="folded-details"><pre><code><span class="syntax"><span class="data-type-modifier">structural</span><span class="blank"> </span><span class="data-type-keyword">ability</span><span class="blank"> </span><span class="hash-qualifier">Control</span><span class="blank"> </span><span class="data-type-params">r</span><span class="control-keyword"> where</span><span class="blank">
</span><span class="blank">  </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o@a0" target="_blank" class="term-reference">control</a><span class="type-ascription-colon"> :</span><span class="blank"> </span><span class="blank">(</span><span class="blank">(</span><span class="var">a</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o" target="_blank" class="type-reference">Control</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank">)</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">r</span><span class="blank">)</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o" target="_blank" class="type-reference">Control</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">a</span></span></code></pre></div></div></div></div><div class="folded-sources"><div class="folded rich source"><div class="fold-toggle"><div class="icon icon-caret-right"><svg width="100%" height="100%" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.08984 9.85306C4.08984 10.2398 4.51004 10.4801 4.84335 10.284L9.53902 7.52188C9.86767 7.32855 9.86767 6.85327 9.53902 6.65994L4.84335 3.89779C4.51004 3.70172 4.08984 3.94204 4.08984 4.32875V9.85306Z" fill="currentColor"></path>
</svg>
</div></div><div class="folded-content"><div class="folded-summary"><pre><code><span class="syntax"><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@fcih3lmvfgmgn6d7jf6g7h3ldt1uokhu4sq8qlh91lom5dbludabiprqcm9gbdq5u0lbepoafvsk61t9aqvr0ffgtglf3kl691e588g" target="_blank" class="term-reference"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">prompt</span></span></a><span class="blank"> </span><span class="type-ascription-colon">: </span><span class="delay-force-char">'</span><span class="ability-braces">{</span><span class="var">e</span><span class="blank">,</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o" target="_blank" class="type-reference">Control</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><span class="var">e</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span></span></code></pre></div><div class="folded-details"><pre><code><span class="syntax"><span class="hash-qualifier"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">prompt</span></span></span><span class="type-ascription-colon"> :</span><span class="blank"> </span><span class="delay-force-char">'</span><span class="ability-braces">{</span><span class="var">e</span><span class="blank">,</span><span class="blank"> </span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/types/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o" target="_blank" class="type-reference">Control</a><span class="blank"> </span><span class="var">r</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank"> </span><span class="type-operator"><span class="arrow">-&gt;</span></span><span class="ability-braces">{</span><span class="var">e</span><span class="ability-braces">}</span><span class="blank"> </span><span class="var">r</span><span class="blank">
</span><span class="hash-qualifier"><span class="fqn"><span class="segment">jitAnnounce</span><span class="sep ">.</span><span class="segment">prompt</span></span></span><span class="blank"> </span><span class="var">e</span><span class="binding-equals"> =</span><span class="blank">
</span><span class="blank">  </span><span class="control-keyword">handle</span><span class="blank"> </span><span class="delay-force-char">!</span><span class="var">e</span><span class="blank">
</span><span class="blank">  </span><span class="control-keyword">with</span><span class="blank">
</span><span class="blank">  </span><span class="blank">  </span><span class="control-keyword">cases</span><span class="blank">
</span><span class="blank">  </span><span class="blank">  </span><span class="blank">  </span><span class="delimeter-char">{</span><span class="blank"> </span><span class="var">x</span><span class="blank"> </span><span class="delimeter-char">}</span><span class="blank">            </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">x</span><span class="blank">
</span><span class="blank">  </span><span class="blank">  </span><span class="blank">  </span><span class="delimeter-char">{</span><a href="https://share.unison-lang.org/@unison/code/latest/namespaces/public/;/terms/@522uj9mq8rmmkfhk8jmn5cenecqu777lhfhhp81mehieqhakqiiq5ccvqsjqt6501ogm3ns3fc4uno1pfv6gjhe4flo4horae6t244o@a0" target="_blank" class="term-reference">control</a><span class="blank"> </span><span class="var">e</span><span class="blank"> </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">k</span><span class="delimeter-char">}</span><span class="blank"> </span><span class="control-keyword"><span class="arrow">-&gt;</span></span><span class="blank"> </span><span class="var">e</span><span class="blank"> </span><span class="var">k</span></span></code></pre></div></div></div></div><p><span class="span"><span class="word">Although I haven't experimented much with them, so I'm not sure how precisely they match the theoretical definitions.</span></span></p></section></div></div></div></span></li></ol><ol start="3"><li><span class="span"><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">actually removes the captured portion in</span><span class="rich source inline-code"><code class="inline-code"><span class="word">k</span></code></span><span class="word">from the control flow context. So, returning directly from the lambda expression yields a value directly to the enclosing</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">.</span></span></span></span></li></ol><p><span class="span"><span class="word">This is essentially how ability handlers work, too. The continuation captured in an ability match only captures a portion of the computation delimited by the associated</span><span class="rich source inline-code"><code class="inline-code"><span class="word">handle</span></code></span><span class="word">block. So,</span><span class="rich source inline-code"><code class="inline-code"><span class="word">handle</span></code></span><span class="word">blocks correspond to the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">operation. The big difference is that we also associate the ability matching, and thus the uses of</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">with the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">handle</span></code></span><span class="word">block.</span></span></p><p><span class="span"><span class="word">However, the intermediate code actually converts this to something more like the Scheme presentation. Ability matching is compiled to code that uses an operation like</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">,</span></span></span><span class="word">so that handled ability requests can actually be implemented by calls to the appropriate generated code. Then references to the implementation are threaded around, and requests are just function calls. So the intermediate code is already ideally suited for a runtime that directly supports delimited continuations.</span></span></p><p><span class="span"><span class="word">There are theoretical results about implementing delimited continuations using</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">and a global mutable variable. I believe the original is in Filinski's</span><span class="group"><span class="join"><a href="https://dl.acm.org/doi/10.1145/174675.178047" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Representing Monads</span></span></a><span class="word">.</span></span></span><span class="word">Essentially the Scheme implementation there is:</span></span></p><div class="rich source code scheme"><pre><code><span class="word">(define mk (lambda (x) (raise "fell off end")))

(define-syntax reset
  (syntax-rules ()
    [(reset e ...)
     (call/cc
       (lambda (k)
         (let ([ok mk])
           (set! mk (lambda (r) (set! mk ok) (k r)))
           (let ([v (begin e ...)]) (mk v)))))]))

(define-syntax shift
  (syntax-rules ()
    [(shift f)
     (call/cc
       (lambda (sk)
         (let* ([k (lambda (x) (reset (sk x)))]
                [v (f k)])
           (mk v))))]))</span></code></pre></div><p><span class="span"><span class="word">However, there seem to be some issues with doing this.</span><a href="https://okmij.org/ftp/continuations/against-callcc.html" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Oleg Kiselyov's</span></span></a><span class="word">page on the downsides of</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">lists some. The most significant problem seems to be that the correctness of the result hinges on every other side effect being subsequently implemented by reduction to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">.</span></span></span><span class="word">However, this ranges from expensive to impossible. Even in Unison, where declared abilities would reduce somehow to the delimited continuations, it is desirable to have some wired in pseudo abilities that implement things more efficiently. Encoding every mutable reference cell using</span><span class="rich source inline-code"><code class="inline-code"><span class="word">shift</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">reset</span></code></span><span class="word">,</span></span></span><span class="word">which are themselves encoded using</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">and a single global variable using closures is a very expensive strategy. And there are also built-in side effects like I/O and threading that are important for us to use.</span></span></p><p><span class="span"><span class="tooltip-trigger" data-tooltip-content-id="tooltip-0"><span class="span"><span class="word">There may be better 'portable' encodings than the one above.</span></span></span><span class="word">But it seems like what is really needed is a careful, system-specific implementation of delimited continuations that definitely interacts well with other parts of the system. Luckily, it should be possible to get this for Chez. As mentioned, Racket now has a Chez backend, and the former has built-in support for delimited continuations.</span></span></p><p><span class="span"><span class="word">Technically, Racket uses its own forked copy of Chez, and the upstream version does not have all the features used for Racket's continuations implementation. There is a pull request against the upstream to add the feature, but it seems to be missing someone to fix some conflicts. I'm uncertain how necessary the feature is just for implementing delimited continuations (Racket uses it for other features as well). We might have to help get the pull request merged, or try using the Racket fork of Chez for our compilation in the end.</span></span></p></section><section><h2 id="conclusion"><span class="word">Conclusion</span></h2><p><span class="span"><span class="word">There's still quite a bit of work to be done, but I think even some of the early results so far are promising. The arithmetic examples mentioned above are much faster than the existing system, and that is on code actually generated from Unison definitions, not hand-crafted output that we could hypothetically generate given enough optimizations.</span></span></p><p><span class="span"><span class="word">I think the data structures I've ported to Unison may also have other uses than this compiler, as well.</span><a href="https://twitter.com/pchiusano/status/1502760429466042368" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">Paul recently demoed a debugging ability</span></span></a><span class="word">he wrote completely in Unison. While discussing it with him, it occurred to me that a lot of the runtime introspection capabilities I've implemented as part of the JIT pipeline could also be useful for providing an even richer debugging experience, with access to all local variables and other niceties. That's something to investigate another time, though.</span></span></p><p><span class="span"><span class="word">Stay tuned for more progress updates on this in the future!</span></span></p></section></section></section><div class="tooltips" style="display: none;"><div id="tooltip-0" class="tooltip-content"><section><p><span class="span"><span class="word">I've at least found</span><span class="group"><span class="join"><a href="http://ix.cs.uoregon.edu/~ariola/tpdc11.pdf" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">A robust implementation of delimited control</span></span></a><span class="word">,</span></span></span><span class="word">which explains how to fix some of the space leaks with the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">version. However:</span></span></p><ol start="1"><li><span class="span"><span class="word">The alternate implementation did not seem to fix the space leak from Oleg's example, at least when I ported it to Chez.</span></span></li><li><span class="span"><span class="word">It's not clear if it solves other problems with the</span><span class="rich source inline-code"><code class="inline-code"><span class="word">call/cc</span></code></span><span class="word">encoding.</span></span></li></ol></section></div></div></article>
{% endraw %}
