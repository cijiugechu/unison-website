---
tags: whats-new
layout: whats-new-post.njk
permalink: whats-new/new-years-update2019/index.html
summary: Hey everyone, Rúnar here. It's been a while since our last update.
  We've been busy.
featuredImage: /assets/thing5.svg
categories:
  - news
authors:
  - runar-bjarnason
date: 2019-01-09T00:00:00.000Z
title: New Years Update 2019
---

{% raw %}
<article class="unison-doc"><section><p></p><section><p><span class="span"><span class="word">Hey everyone, Rúnar here. It's been a while since our last update. We've been busy.</span></span></p><section><h2 id="spreading-the-word-about-unison"><span class="span"><span class="word">Spreading the word about Unison</span></span></h2><ul><li><span class="span"><span class="word">The video of</span><a href="https://www.youtube.com/watch?v=rp_Eild1aq8" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">my talk from Lambda World Seattle</span></span></a><span class="word">has been published to YouTube.</span></span></li><li><span class="span"><span class="word">Paul's talk</span><a href="https://www.youtube.com/watch?v=v7L-5AQQkbM" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">at Scale by the Bay</span></span></a><span class="word">is also up.</span></span></li><li><span class="span"><span class="word">I gave a talk on Unison at Øredev in Malmö, and also at the Reykjavík Functional Programming meetup.</span><span class="group"><span class="join"><a href="https://www.facebook.com/enkidudidu/videos/10218046671060964/" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">A video is available of the latter</span></span></a><span class="word">.</span></span></span></span></li><li><span class="span"><span class="word">Arya did the hallway track at NeurIPS and got a sense of how researchers and industry are (or aren't) managing their distributed machine learning applications. This seems a good candidate for a Unison library.</span></span></li><li><span class="span"><span class="word">We created a number of GitHub issues and marked some of them as "good first issue" and "help wanted". If you've been thinking about contributing to Unison, this might be a good place to start. We'll add to these issues as we think of more ways contributors can help. Go to</span><a href="https://github.com/unisonweb/unison/issues" class="named-link" rel="noopener" target="_blank"><span class="word">https://github.com/unisonweb/unison/issues</span></a><span class="word">to look at the list.</span></span></li></ul></section><section><h2 id="codebase-editor-progress"><span class="span"><span class="word">Codebase editor progress</span></span></h2><p><span class="span"><span class="word">Meanwhile, we're making steady progress on the implementation, working mostly on the Unison codebase editor. Here's what you get now when you start up</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">unison</span></code></span><span class="word">:</span></span></span></span></p><img src="/assets/feed/new-years-update-2019/cbestart.png" alt="Starting the codebase editor"><p><span class="span"><span class="word">From here, you can explore and manipulate your Unison codebase. You'll note that Unison first creates a</span><span class="italic"><span class="word">branch</span></span><span class="word">called "master". A branch is really two things:</span></span></p><ol start="1"><li><span class="span"><span class="word">A collection of names for the hashes in your codebase.</span></span></li><li><span class="span"><span class="word">A collection of edits to the codebase.</span></span></li></ol><p><span class="span"><span class="word">Right from the start, the master branch contains a number of predefined names for builtins. You can query the contents of the codebase using fuzzy matching:</span></span></p><img src="/assets/feed/new-years-update-2019/ls-drp.png" alt="ls drp"><p><span class="span"><span class="word">The codebase knows the type of every definition, and later on we'll add the ability to query by type.</span></span></p><p><span class="span"><span class="word">Oh, and we have tab completion already.</span></span></p><section><h3 id="unison-is-watching"><span class="span"><span class="word">Unison is watching</span></span></h3><p><span class="span"><span class="word">Instead of having a REPL in the traditional sense, Unison is watching for changes to</span><span class="rich source inline-code"><code class="inline-code"><span class="word">*.u</span></code></span><span class="word">files under the directory in which it's started. I'll open a file called</span><span class="rich source inline-code"><code class="inline-code"><span class="word">scratch.u</span></code></span><span class="word">and type a Unison definition into it:</span></span></p><img src="/assets/feed/new-years-update-2019/replicate.png" alt="replicate"><p><span class="span"><span class="word">If I save the file, my Unison session immediately shows this:</span></span></p><img src="/assets/feed/new-years-update-2019/scratchu.png" alt="saved scratch.u"><p><span class="span"><span class="word">Note that it says it's "evaluating any watch expressions". I can add a watch expression just by adding a line that starts with</span><span class="rich source inline-code"><code class="inline-code"><span class="word">&gt;</span></code></span><span class="word">to my file.</span></span></p><img src="/assets/feed/new-years-update-2019/replicatelambda.png" alt="replicate 3 lambda"><p><span class="span"><span class="word">If I save again, Unison comes back with the evaluated result of this expression:</span></span></p><img src="/assets/feed/new-years-update-2019/evalreplicatelambda.png" alt="eval replicate 3 lambda"></section><section><h3 id="adding-and-viewing-definitions"><span class="span"><span class="word">Adding and viewing definitions</span></span></h3><p><span class="span"><span class="word">I'm happy with that, so I'll ask Unison to add</span><span class="rich source inline-code"><code class="inline-code"><span class="word">replicate</span></code></span><span class="word">to my codebase:</span></span></p><img src="/assets/feed/new-years-update-2019/unisonadd.png" alt="unison add"><p><span class="span"><span class="word">If I had put more (well typed) definitions in my file, Unison would have happily added those too.</span></span></p><p><span class="span"><span class="word">Now that</span><span class="rich source inline-code"><code class="inline-code"><span class="word">replicate</span></code></span><span class="word">is in my codebase, I can actually throw away the scratch file. If I need the definition of</span><span class="rich source inline-code"><code class="inline-code"><span class="word">replicate</span></code></span><span class="word">again, I can always ask Unison for it:</span></span></p><img src="/assets/feed/new-years-update-2019/viewreplicate.png" alt="view replicate"></section><section><h3 id="git-friendly-codebase-structure"><span class="span"><span class="word">Git-friendly codebase structure</span></span></h3><p><span class="span"><span class="word">We really want to allow Unison developers to use good tools they're already familiar with like their favourite text editor, and Git. To that end, we've made it so that the codebase is just a bunch of (binary) files that can be versioned with Git.</span></span></p><p><span class="span"><span class="word">Under the bonnet, Unison creates a directory called</span><span class="rich source inline-code"><code class="inline-code"><span class="word">.unison</span></code></span><span class="word">which contains the codebase. There are three subdirectories here (currently); one for branches, one for type declarations, and one for term definitions. Under</span><span class="rich source inline-code"><code class="inline-code"><span class="word">types</span></code></span><span class="word">and</span><span class="group"><span class="join"><span class="rich source inline-code"><code class="inline-code"><span class="word">terms</span></code></span><span class="word">,</span></span></span><span class="word">we have one directory per hash which contains the compiled definition as well as any metadata.</span></span></p><img src="/assets/feed/new-years-update-2019/codebasestructure.png" alt="Unison codebase structure"><p><span class="span"><span class="word">Since everything is indexed by hash, you'll never actually change any file, so Git merge conflicts should never happen.</span></span></p><p><span class="span"><span class="word">See</span><a href="https://github.com/unisonweb/unison/blob/trunk/docs/codebase-editor-design.markdown" class="named-link" rel="noopener" target="_blank"><span class="span"><span class="word">the Codebase Editor design document</span></span></a><span class="word">for more information.</span></span></p></section><section><h3 id="more-features"><span class="span"><span class="word">More features</span></span></h3><p><span class="span"><span class="word">We're currently adding more features to the Codebase Editor. Right now we're making it easier to edit existing definitions that have a lot of dependencies, through a kind of structured refactoring session.</span></span></p><p><span class="span"><span class="word">Here's the feature set we have so far:</span></span></p><img src="/assets/feed/new-years-update-2019/unisonhelp.png" alt="Unison help"></section></section></section></section><div class="tooltips" style="display: none;"></div></article>
{% endraw %}
